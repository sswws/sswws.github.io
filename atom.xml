<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>韩昊洋博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-30T13:00:08.376Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>韩昊洋</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Day30前端面试题</title>
    <link href="http://example.com/2023/03/30/Day30%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/30/Day30%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-30T12:56:18.000Z</published>
    <updated>2023-03-30T13:00:08.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-为什么存在数字精度丢失的问题，如何解决？"><a href="#JS-为什么存在数字精度丢失的问题，如何解决？" class="headerlink" title="JS 为什么存在数字精度丢失的问题，如何解决？"></a>JS 为什么存在数字精度丢失的问题，如何解决？</h1><p>在 JavaScript 中存在数字精度丢失的问题，这是因为 JavaScript 采用的是 IEEE 754 标准的浮点数表示法，而浮点数只能精确地表示有限的数字，而不能精确地表示无限的数字。这种浮点数表示法的问题在计算机科学中是普遍存在的。</p><p>由于 JavaScript 中采用的是浮点数表示法，因此对于一些浮点数运算，可能会产生精度丢失的问题。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>在这个例子中，由于 0.1 和 0.2 都无法用二进制精确表示，因此在进行运算时会产生精度丢失的问题。</p><p>为了解决这个问题，可以采用以下两种方法：</p><ol><li>使用 Decimal.js 等库：可以使用一些库，如 Decimal.js、big.js 等，来解决 JavaScript 中的数字精度问题。这些库提供了高精度计算功能，可以避免浮点数精度丢失的问题。</li><li>使用整数计算：如果计算中只涉及整数，可以将浮点数转换成整数，进行整数运算，然后再将结果转换成浮点数。这样可以避免浮点数精度丢失的问题。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">10</span> + <span class="number">0.2</span> * <span class="number">10</span> <span class="comment">// 3</span></span><br><span class="line">(<span class="number">0.1</span> * <span class="number">10</span> + <span class="number">0.2</span> * <span class="number">10</span>) / <span class="number">10</span> <span class="comment">// 0.3</span></span><br></pre></td></tr></table></figure><p>这种方法可以在保证精度的同时，避免使用第三方库的问题。但需要注意的是，在进行浮点数运算时，仍然可能会产生精度丢失的问题。因此，在进行精度要求较高的计算时，建议使用第一种方法。</p><h1 id="什么是前端跨平台？你用过哪些跨平台框架？"><a href="#什么是前端跨平台？你用过哪些跨平台框架？" class="headerlink" title="什么是前端跨平台？你用过哪些跨平台框架？"></a>什么是前端跨平台？你用过哪些跨平台框架？</h1><p>前端跨平台是指可以在不同的操作系统、不同的浏览器或设备上运行相同的前端应用程序，达到统一的用户体验。目前主要的前端跨平台技术包括以下几种：</p><ol><li>响应式设计：通过 CSS3 媒体查询和弹性布局等技术，使得网站在不同的设备上能够自适应地显示，并提供统一的用户体验。</li><li>Progressive Web App（PWA）：是一种利用现代 Web 技术开发的应用程序，具有类似于原生应用的交互和体验。PWA 可以在任何平台上运行，可以通过安装到设备主屏幕、离线访问等方式提供更好的用户体验。</li><li>跨平台框架：使用跨平台框架可以开发出一份代码，然后通过框架提供的工具将代码转换成可以在多个平台上运行的应用程序。主要的跨平台框架包括 React Native、Flutter、Ionic、Electron 等。</li></ol><p>我用过的跨平台框架包括 React Native 和 Electron。React Native 可以在 iOS 和 Android 平台上开发原生应用，同时也可以在 Web 平台上使用 React 框架进行开发。Electron 可以将 Web 应用程序打包成桌面应用程序，可以在 Windows、macOS 和 Linux 等多个平台上运行。这些跨平台框架可以大大简化开发过程，提高开发效率，同时也可以保证应用程序在多个平台上的兼容性和用户体验。</p><h1 id="什么是-Javascript-的事件流？有哪些事件流模型？"><a href="#什么是-Javascript-的事件流？有哪些事件流模型？" class="headerlink" title="什么是 Javascript 的事件流？有哪些事件流模型？"></a>什么是 Javascript 的事件流？有哪些事件流模型？</h1><p>JavaScript 的事件流是指浏览器中所有事件的传递和处理过程。事件流可以分为三个阶段：事件捕获、目标阶段和事件冒泡。</p><ol><li>事件捕获阶段：事件从最外层的文档节点一直往下传递，直到事件到达事件的目标元素。在这个过程中，事件会经过父节点和祖先节点，直到到达目标节点。如果在这个过程中有事件处理程序，则事件将被调用。</li><li>目标阶段：事件到达了目标元素后，将在目标元素上调用事件处理程序。如果有多个事件处理程序绑定到目标元素上，将按照它们的顺序执行。</li><li>事件冒泡阶段：事件在目标元素上处理后，会从目标元素开始，向上传递回文档节点。在这个过程中，事件也会遇到任何绑定的事件处理程序。</li></ol><p>目前有两种事件流模型：</p><ol><li>W3C 标准事件模型（DOM2级事件模型）：事件流由三个阶段组成：捕获阶段、目标阶段和冒泡阶段。这种事件模型中，事件处理程序的调用顺序与它们注册的顺序相同。</li><li>Microsoft 事件模型（IE 事件模型）：事件流由两个阶段组成：目标阶段和冒泡阶段。在这个事件模型中，事件处理程序的调用顺序与它们注册的相反。</li></ol><p>总体来说，W3C 标准事件模型是当前主流的事件流模型。对于事件流，我们需要了解事件捕获、目标阶段和事件冒泡，以便于正确地使用事件处理程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-为什么存在数字精度丢失的问题，如何解决？&quot;&gt;&lt;a href=&quot;#JS-为什么存在数字精度丢失的问题，如何解决？&quot; class=&quot;headerlink&quot; title=&quot;JS 为什么存在数字精度丢失的问题，如何解决？&quot;&gt;&lt;/a&gt;JS 为什么存在数字精度丢失的问题</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day29前端面试题</title>
    <link href="http://example.com/2023/03/30/Day29%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/30/Day29%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-30T12:52:30.000Z</published>
    <updated>2023-03-30T12:55:51.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么调试-Node-js-程序？"><a href="#怎么调试-Node-js-程序？" class="headerlink" title="怎么调试 Node.js 程序？"></a>怎么调试 Node.js 程序？</h1><p>调试 Node.js 程序有多种方法，以下是一些常见的调试技巧和工具：</p><p>使用 console.log()：在代码中添加 console.log() 语句，输出变量值、函数执行情况等，以便了解程序运行状态。这是最基本的调试手段，适用于简单的问题排查。</p><p>使用内置调试器：Node.js 提供了一个内置的命令行调试器。要使用它，只需在启动脚本时在命令行中添加 inspect 或 inspect-brk 标志，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node inspect app.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --inspect-brk app.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>这将启动一个调试会话。你可以在代码中添加 debugger; 语句，作为断点。调试器将在遇到断点时暂停执行。</p><p>使用 Chrome DevTools：你可以使用 Chrome DevTools 来调试 Node.js 程序。首先，使用 inspect 或 inspect-brk 标志启动 Node.js 应用，然后打开 Chrome 浏览器，输入 chrome:&#x2F;&#x2F;inspect，在 “Devices” 下找到你的 Node.js 应用，并点击 “inspect”。这将打开一个 DevTools 实例，你可以像调试浏览器中的 JavaScript 代码一样调试 Node.js 代码。</p><p>使用 Visual Studio Code：Visual Studio Code 是一个流行的开源代码编辑器，内置了对 Node.js 的调试支持。要在 VSCode 中调试 Node.js 应用，需要创建一个名为 .vscode&#x2F;launch.json 的配置文件，配置调试参数。以下是一个简单的配置示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Launch Program&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/app.js&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，按下 F5 或点击左侧 “Run and Debug” 选项卡上的 “Run” 按钮开始调试。你可以在代码中添加断点、查看变量值、使用控制台等。</p><p>使用其他 IDE 和编辑器：许多其他 IDE 和代码编辑器也提供了 Node.js 调试支持，如 WebStorm、Atom 等。具体操作方法因工具而异，请参考相应工具的文档。</p><p>选择合适的调试工具和方法可以帮助你更高效地找到和解决 Node.js 程序中的问题。</p><h1 id="你用过哪些包管理工具？它们各有什么特点？"><a href="#你用过哪些包管理工具？它们各有什么特点？" class="headerlink" title="你用过哪些包管理工具？它们各有什么特点？"></a>你用过哪些包管理工具？它们各有什么特点？</h1><p>前端常见的包管理工具包括 npm、Yarn 和 PNPM，它们各有不同的特点：</p><ol><li>npm：npm 是 Node.js 自带的包管理工具，也是前端开发中最常用的包管理工具之一。它是一个基于命令行的工具，可以方便地安装、管理和升级依赖包。npm 拥有丰富的开源包，使用方便，但可能会出现包冲突等问题。</li><li>Yarn：Yarn 是 Facebook 开源的包管理工具，它是为了解决 npm 在包安装速度和版本管理上的一些问题而开发的。Yarn 支持离线安装、并行下载等特性，可以提高包安装的速度和可靠性。与 npm 相比，Yarn 具有更好的性能和稳定性，但是可能会出现版本冲突的问题。</li><li>PNPM：PNPM 是另一种基于命令行的包管理工具，它也可以用于安装和管理依赖包。与 npm 和 Yarn 不同的是，PNPM 支持重用已安装的包，减少了重复下载包的问题，从而提高了安装速度和减少了磁盘空间占用。PNPM 支持锁定版本、并行安装、缓存依赖等特性，但可能需要更多的学习成本。</li></ol><p>综上所述，npm、Yarn 和 PNPM 都是可靠的包管理工具，使用场景和需求不同可以选择不同的工具。一般来说，对于小型项目或初学者，使用 npm 即可；对于大型项目或需要更好的性能和可靠性的项目，可以考虑使用 Yarn 或 PNPM。</p><h1 id="SPA（单页应用）首屏加载速度慢怎么解决？"><a href="#SPA（单页应用）首屏加载速度慢怎么解决？" class="headerlink" title="SPA（单页应用）首屏加载速度慢怎么解决？"></a>SPA（单页应用）首屏加载速度慢怎么解决？</h1><p>单页应用（SPA）由于其特点，在首屏加载时，可能会出现加载速度慢的问题。为了解决这个问题，可以采用以下策略和技巧：</p><ol><li>代码拆分（Code Splitting）：将大型 JavaScript 文件拆分成更小的文件，按需加载。这可以通过使用动态导入（import() 语法）和 Webpack 等打包工具实现。代码拆分可以确保仅加载当前页面所需的代码，从而减少首屏加载时间。</li><li>懒加载（Lazy Loading）：只在需要时加载某些资源，如图片、视频和其他媒体内容。懒加载可以通过 JavaScript 代码实现，或使用新的 loading&#x3D;”lazy” 属性（适用于部分现代浏览器）。</li><li>缓存策略：利用浏览器缓存来存储静态资源，如 CSS、JavaScript、图片等。可以通过设置 HTTP 缓存头来实现，如 Cache-Control、ETag 等。合理的缓存策略可以减少重复请求，提高首屏加载速度。</li><li>优化 JavaScript、CSS 和 HTML：压缩、混淆和缩小 JavaScript 和 CSS 文件，移除不必要的空格、注释和代码。对 HTML 文件进行类似的处理。可以使用诸如 UglifyJS、Terser、CSSNano 等工具进行优化。</li><li>使用 CDN（内容分发网络）：将静态资源部署到 CDN 上，可以使用户从最近的服务器获取资源，从而加速首屏加载速度。</li><li>服务端渲染（SSR）或预渲染（Prerendering）：通过在服务器端渲染初始 HTML，加快首次渲染速度。预渲染可以在构建阶段生成静态 HTML 文件，从而避免客户端在首次加载时执行过多的 JavaScript 代码。</li><li>优化网络请求：减少不必要的网络请求，合并多个请求（如使用 CSS Sprites 或 HTTP&#x2F;2 多路复用），以及优先加载关键资源。</li><li>优先加载关键路径（Critical Path）：确保首屏渲染所需的关键 CSS 和 JavaScript 代码优先加载。可以将关键 CSS 内联到 HTML 中，以避免额外的请求。</li><li>使用性能分析工具：利用诸如 Lighthouse、WebPageTest 和 Chrome DevTools 等工具分析应用性能，找出瓶颈并进行优化。</li></ol><p>通过采用以上策略，可以有效地提高 SPA 首屏加载速度，提升用户体验。这些方法需要针对具体的项目进行调整和实施，从而达到最佳效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么调试-Node-js-程序？&quot;&gt;&lt;a href=&quot;#怎么调试-Node-js-程序？&quot; class=&quot;headerlink&quot; title=&quot;怎么调试 Node.js 程序？&quot;&gt;&lt;/a&gt;怎么调试 Node.js 程序？&lt;/h1&gt;&lt;p&gt;调试 Node.js 程序有</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day28前端面试题</title>
    <link href="http://example.com/2023/03/19/Day28%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/19/Day28%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-19T02:03:15.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-有哪些全局对象？它们分别有什么作用？"><a href="#Node-js-有哪些全局对象？它们分别有什么作用？" class="headerlink" title="Node.js 有哪些全局对象？它们分别有什么作用？"></a>Node.js 有哪些全局对象？它们分别有什么作用？</h1><p>Node.js 中有一些全局对象，它们可以在任何模块中直接访问，无需进行导入。以下是一些常见的全局对象及其作用：</p><ol><li>global：它是 Node.js 的全局命名空间，类似于浏览器环境中的 window 对象。在 global 对象上定义的属性和方法可以在任何地方访问。然而，在实际开发中，应避免在 global 对象上添加属性，以防止全局命名空间污染。</li><li>process：它是一个全局对象，提供了关于当前 Node.js 进程的信息和对其进行控制的方法。process 对象包含诸如环境变量、命令行参数、内存使用情况、当前工作目录等属性和方法。</li><li>console：它是一个全局对象，提供了用于输出信息和调试的方法，如 console.log()、console.error()、console.warn() 等。</li><li>setTimeout 和 clearTimeout：这两个方法用于设置和清除定时器。setTimeout 方法用于在指定的毫秒数后执行一个回调函数，clearTimeout 方法用于取消一个先前通过 setTimeout 设置的定时器。</li><li>setInterval 和 clearInterval：这两个方法用于设置和清除周期性定时器。setInterval 方法用于每隔指定的毫秒数执行一个回调函数，clearInterval 方法用于取消一个先前通过 setInterval 设置的定时器。</li><li>setImmediate 和 clearImmediate：这两个方法用于在当前事件循环结束时执行一个回调函数。setImmediate 方法会将回调函数添加到事件循环的队列末尾，以便在当前事件循环的所有 I&#x2F;O 事件和定时器事件处理完毕后执行。clearImmediate 方法用于取消一个先前通过 setImmediate 设置的回调函数。</li><li>Buffer：它是一个全局的构造函数，用于处理二进制数据，如文件 I&#x2F;O、网络 I&#x2F;O 等。Buffer 提供了一系列方法来创建和操作字节缓冲区。</li><li>require 和 module：require 是一个全局函数，用于导入其他模块。module 是一个全局对象，表示当前模块。每个 Node.js 文件都是一个模块，模块可以导出函数、对象或值，以便其他模块使用。</li></ol><p>注意，虽然这些对象在全局范围内可用，但它们并非严格意义上的全局变量。在 Node.js 模块中，它们是模块作用域内的变量，这意味着在一个模块中定义的变量不会自动成为全局变量。</p><h1 id="简述-TCP-x2F-IP-网络模型，分为几层？每层的职责和作用是什么？"><a href="#简述-TCP-x2F-IP-网络模型，分为几层？每层的职责和作用是什么？" class="headerlink" title="简述 TCP&#x2F;IP 网络模型，分为几层？每层的职责和作用是什么？"></a>简述 TCP&#x2F;IP 网络模型，分为几层？每层的职责和作用是什么？</h1><p>TCP&#x2F;IP 网络模型（也称为互联网协议套件）是一种用于描述网络通信的概念模型。它分为四层，每层都有特定的职责和作用，它们分别是：</p><ol><li>应用层（Application Layer）：应用层负责处理与应用程序的通信和数据传输。它包括各种应用层协议，例如 HTTP、HTTPS、FTP、SMTP、IMAP、POP3、DNS 等。这些协议定义了客户端和服务器之间如何互相发送和接收数据。应用层的主要职责是为应用程序提供用户接口、数据传输以及数据封装和解封装。</li><li>传输层（Transport Layer）：传输层主要负责在网络中进行端到端的可靠数据传输。它提供了两种主要的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。TCP 提供了可靠、面向连接的数据传输，它可以确保数据在传输过程中不会丢失、重复或乱序。UDP 提供了不可靠、无连接的数据传输，它不能保证数据的传输质量，但传输速度更快，适用于实时通信等场景。</li><li>网络层（Internet Layer）：网络层负责在不同网络之间进行数据包的路由和传输。它使用 IP（互联网协议）进行寻址和路由，将数据包从源主机传输到目的主机。网络层的主要职责包括：IP 地址分配、路由选择、分片和重组以及错误检测和处理。除了 IP 协议，网络层还包括其他协议，如 ICMP（互联网控制消息协议）和 IGMP（互联网组管理协议）。</li><li>链路层（Link Layer）：链路层（又称网络接口层或数据链路层）负责在同一网络中进行数据帧的发送和接收。链路层的协议因网络硬件而异，如 Ethernet、Wi-Fi、PPP 等。链路层的主要职责包括：物理寻址、数据帧封装和解封装、差错检测、流量控制以及链路管理。</li></ol><p>总的来说，TCP&#x2F;IP 网络模型将网络通信划分为四个层次，每层都有自己的职责和功能。这种分层模型有助于降低网络系统的复杂性，便于设计、实现和维护网络协议和设备。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Node-js-有哪些全局对象？它们分别有什么作用？&quot;&gt;&lt;a href=&quot;#Node-js-有哪些全局对象？它们分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;Node.js 有哪些全局对象？它们分别有什么作用？&quot;&gt;&lt;/a&gt;Node.js </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day27前端面试题</title>
    <link href="http://example.com/2023/03/18/Day27%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/18/Day27%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-18T04:00:42.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？"><a href="#JS-会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？" class="headerlink" title="JS 会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？"></a>JS 会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？</h1><p>JavaScript 也会出现内存泄漏问题。内存泄漏是指一些被分配的内存空间，因为某些原因而无法被垃圾回收机制回收，导致占用内存空间无法被释放，最终会导致程序崩溃。</p><p>在 JavaScript 中，内存泄漏通常出现在以下情况：</p><ol><li>意外的全局变量：如果一个变量没有被垃圾回收，那么它的作用域会被认为是全局的，这样就会造成意外的全局变量，导致内存泄漏。</li><li>定时器没有被清除：如果在页面关闭前，某个定时器没有被清除，它所引用的对象就不会被垃圾回收，从而导致内存泄漏。</li><li>闭包：如果一个闭包中引用了外部变量，而这个闭包被其他代码引用，那么它所引用的外部变量就不会被垃圾回收，从而导致内存泄漏。</li><li>DOM 引用：如果在页面上有大量的 DOM 元素，而这些元素被 JavaScript 代码所引用，但是却没有被正确地释放，就会导致内存泄漏。</li><li>循环引用：如果两个或多个对象之间形成了循环引用，即相互引用对方，那么它们都不会被垃圾回收，从而导致内存泄漏。</li></ol><p>为了避免 JavaScript 中的内存泄漏问题，可以采取以下措施：</p><ol><li>避免意外的全局变量，可以使用 “use strict” 模式，或者在函数中使用 var、let 或 const 声明变量。</li><li>在使用定时器时，一定要记得及时清除定时器。</li><li>尽量避免使用闭包，如果必须使用闭包，要注意不要引用外部变量或者及时清除闭包。</li><li>在操作 DOM 元素时，要及时释放引用，避免 DOM 引用导致内存泄漏。</li><li>避免循环引用，可以在对象不再使用时，手动断开对象之间的引用关系。</li></ol><h1 id="HTTP-缓存有哪些实现方式？什么是协商缓存和强制缓存？"><a href="#HTTP-缓存有哪些实现方式？什么是协商缓存和强制缓存？" class="headerlink" title="HTTP 缓存有哪些实现方式？什么是协商缓存和强制缓存？"></a>HTTP 缓存有哪些实现方式？什么是协商缓存和强制缓存？</h1><p>HTTP 缓存可以通过以下几种方式进行实现：</p><ol><li>浏览器缓存：浏览器可以将最近请求过的资源保存到本地，下次请求时可以直接从本地读取，从而提高访问速度。</li><li>代理缓存：代理服务器可以缓存响应，减少对原始服务器的请求次数，从而加快响应速度。</li><li>网关缓存：网关可以缓存来自多个原始服务器的响应，然后将响应发送到客户端，从而提高性能。</li></ol><p>HTTP 缓存可以分为协商缓存和强制缓存两种类型。</p><p>强制缓存是指浏览器在请求资源时，不会发送任何请求头，直接从本地缓存中读取资源，从而提高响应速度。常见的实现方式包括：</p><ol><li>Expires 头部：指定资源过期的时间，如果在过期时间之前再次请求该资源，浏览器将直接从缓存中读取资源。</li><li>Cache-Control 头部：可以指定资源的缓存策略，包括 public、private、no-cache 等，控制浏览器的缓存行为。</li></ol><p>协商缓存是指浏览器在请求资源时，会发送一些请求头到服务器，询问服务器资源是否已经发生改变。如果资源未发生改变，服务器将返回 304 状态码，告诉浏览器可以从缓存中读取资源，从而减少了网络带宽的使用。常见的实现方式包括：</p><ol><li>Last-Modified &#x2F; If-Modified-Since 头部：浏览器在请求资源时，会将资源最后修改时间（Last-Modified）发送到服务器，服务器检查资源是否发生变化，如果没有发生变化，返回 304 状态码，否则返回新的资源。</li><li>ETag &#x2F; If-None-Match 头部：服务器可以给每个资源分配一个唯一的标识符（ETag），浏览器在请求资源时，将该标识符发送到服务器，服务器检查资源是否发生变化，如果没有发生变化，返回 304 状态码，否则返回新的资源。</li></ol><p>需要注意的是，协商缓存虽然可以减少网络带宽的使用，但是需要服务器进行资源比较，因此会增加服务器的负载。</p><h1 id="怎么进行站点内的图片性能优化？"><a href="#怎么进行站点内的图片性能优化？" class="headerlink" title="怎么进行站点内的图片性能优化？"></a>怎么进行站点内的图片性能优化？</h1><p>站点内的图片性能优化可以从以下几个方面入手：</p><ol><li>图片压缩：通过压缩图片的大小和质量，可以减少图片的加载时间。可以使用图片压缩工具（如 TinyPNG、JPEGmini 等）来压缩图片。</li><li>图片格式优化：选择正确的图片格式可以减少图片的大小。常见的图片格式有 JPEG、PNG 和 GIF，可以根据图片的特点和用途选择合适的格式。</li><li>延迟加载：对于页面中的长列表或懒加载场景，可以延迟加载图片，减少页面加载时间。可以使用工具（如 lazysizes、Lozad.js 等）来实现图片的延迟加载。</li><li>图片预加载：在用户访问页面之前，可以预加载一些重要的图片，从而提高用户体验。可以使用工具（如 PreloadJS、image-preload 等）来实现图片的预加载。</li><li>响应式图片：对于不同大小的屏幕，可以使用不同大小的图片来提高用户体验。可以使用 HTML 标签的 srcset 和 sizes 属性来实现响应式图片。</li><li>CDN 加速：使用 CDN 可以加速图片的加载速度，缩短图片的响应时间。可以选择静态文件托管服务商（如七牛云、阿里云等）来实现 CDN 加速。</li><li>图片懒加载：对于网页中需要加载大量图片的场景，可以使用图片懒加载技术，即当页面滚动到某个区域时再加载该区域内的图片，从而减少页面加载时间和网络带宽的消耗。可以使用工具（如 lazyload、intersection-observer 等）来实现图片懒加载。</li></ol><p>需要注意的是，以上优化策略都是针对特定场景和需求进行优化的，需要根据实际情况选择合适的优化策略。同时，在进行图片优化时，需要保证图片质量和用户体验，并注意不要过度压缩图片，影响用户体验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？&quot;&gt;&lt;a href=&quot;#JS-会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？&quot; class=&quot;headerlink&quot; title=&quot;JS 会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day26前端面试题</title>
    <link href="http://example.com/2023/03/18/Day26%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/18/Day26%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-18T03:56:56.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Node-js-的事件循环机制？它是怎么实现的？"><a href="#什么是-Node-js-的事件循环机制？它是怎么实现的？" class="headerlink" title="什么是 Node.js 的事件循环机制？它是怎么实现的？"></a>什么是 Node.js 的事件循环机制？它是怎么实现的？</h1><p>Node.js 的事件循环（Event Loop）机制是 Node.js 中实现异步非阻塞 I&#x2F;O 的核心。事件循环允许 Node.js 可以在单个线程中处理高并发的请求，提高了程序的性能和响应能力。</p><p>事件循环是 Node.js 的运行机制，负责调度和处理各种事件（如 I&#x2F;O 操作、定时器、网络请求等）。以下是事件循环的主要实现流程：</p><ol><li>Node.js 在启动时会初始化事件循环。</li><li>执行输入的脚本，可能会注册各种事件（如 I&#x2F;O 操作、定时器等）。</li><li>事件循环开始运行，进入不同的阶段（Phases），如 Timers、I&#x2F;O callbacks、Idle&#x2F;Prepare、Poll、Check 和 Close callbacks。每个阶段负责处理特定类型的事件。</li><li>当事件队列中的事件被处理完毕，事件循环会检查是否还有待处理的事件或回调。如果没有，事件循环结束，程序退出；否则，事件循环继续运行，处理新的事件。</li><li>Node.js 的事件循环机制是基于 libuv 库实现的。libuv 是一个跨平台的异步 I&#x2F;O 库，提供了事件循环、线程池等功能。Node.js 使用 libuv 来实现事件循环，处理各种异步操作，如文件 I&#x2F;O、网络请求、定时器等。</li></ol><p>值得注意的是，Node.js 的事件循环与浏览器的事件循环有一定的区别。虽然它们的核心概念相似，但在实现细节和运行环境上有所不同。在使用 Node.js 时，需要理解其事件循环的特点，以便更好地编写异步代码。</p><h1 id="DNS-预解析是什么？怎么实现？"><a href="#DNS-预解析是什么？怎么实现？" class="headerlink" title="DNS 预解析是什么？怎么实现？"></a>DNS 预解析是什么？怎么实现？</h1><p>DNS 预解析（DNS Prefetching）是一种网络性能优化技术，用于提前解析用户可能访问的域名，以减少实际请求时的 DNS 解析时间。通过预解析，浏览器可以在用户实际访问一个链接之前就已经获取到对应的 IP 地址，从而降低网络延迟，加快页面加载速度。</p><p>DNS 预解析主要有两种实现方式：</p><p>自动预解析：现代浏览器通常会自动进行 DNS 预解析。浏览器会根据用户的浏览历史和页面内容分析可能需要预解析的域名，然后在后台进行 DNS 解析。这种方式无需开发者进行任何操作，浏览器会自动进行预解析。</p><p>手动预解析：开发者可以通过在 HTML 文档中添加标签来手动指定需要进行预解析的域名。这种方式可以让开发者更精确地控制哪些域名需要进行预解析。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;link rel=<span class="string">&quot;dns-prefetch&quot;</span> href=<span class="string">&quot;//example.com&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//cdn.example.com&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ...</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用标签并设置 rel 属性为 dns-prefetch，将 href 属性设置为需要预解析的域名。注意，域名前需要加上&#x2F;&#x2F;，表示使用当前页面的协议（HTTP 或 HTTPS）。</p><p>使用 DNS 预解析可以在一定程度上提高网页的加载速度和用户体验，但需要注意的是，过多的预解析可能会消耗用户的网络资源和带宽。因此，在实际应用中，应该根据实际需求合理地使用 DNS 预解析。</p><h1 id="什么是低代码？你用过哪些低代码工具？"><a href="#什么是低代码？你用过哪些低代码工具？" class="headerlink" title="什么是低代码？你用过哪些低代码工具？"></a>什么是低代码？你用过哪些低代码工具？</h1><p>低代码（Low-Code）是一种软件开发方法，它允许开发者通过可视化界面、拖拽组件和一些简单的逻辑配置来构建应用程序，而无需编写大量的代码。低代码平台的目标是提高开发效率，降低开发难度，使非专业开发人员（如业务分析师、产品经理等）也能参与到应用程序的开发过程中。</p><p>低代码平台的主要特点包括：</p><ol><li>可视化界面：低代码平台通常提供可视化的界面设计工具，开发者可以通过拖拽组件、配置属性等方式来构建应用程序界面。</li><li>预构建组件：低代码平台提供一系列预构建的组件和模板，开发者可以直接使用这些组件，而无需从头编写代码。</li><li>逻辑配置：低代码平台允许开发者通过图形化界面或简单的脚本语言来配置应用程序的逻辑，降低了编程难度。</li><li>一键部署：低代码平台通常提供一键部署功能，开发者可以轻松地将应用程序发布到目标环境中。</li></ol><p>一些常见的低代码工具和平台包括：</p><ol><li>OutSystems：一款功能强大的低代码开发平台，适用于构建企业级应用程序，支持 Web 和移动应用开发。</li><li>Appian：提供低代码开发和业务流程管理功能，适用于构建企业应用程序，特别是需要复杂流程控制的场景。</li><li>Microsoft Power Apps：Microsoft 推出的低代码应用程序开发平台，可以轻松地与其他 4. Microsoft 365 服务集成。</li><li>Mendix：一款低代码开发平台，提供丰富的预构建组件和可视化开发工具，适用于构建企业应用程序。</li></ol><p>虽然低代码平台可以提高开发效率，但在某些场景下，它们可能无法满足复杂的定制需求或实现高度优化的性能。因此，在选择低代码平台时，需要根据项目需求和团队技能来权衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-Node-js-的事件循环机制？它是怎么实现的？&quot;&gt;&lt;a href=&quot;#什么是-Node-js-的事件循环机制？它是怎么实现的？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Node.js 的事件循环机制？它是怎么实现的？&quot;&gt;&lt;/a&gt;什么</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day25前端面试题</title>
    <link href="http://example.com/2023/03/16/Day25%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/16/Day25%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-16T04:33:36.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么使用-JS-实现元素拖拽功能？"><a href="#怎么使用-JS-实现元素拖拽功能？" class="headerlink" title="怎么使用 JS 实现元素拖拽功能？"></a>怎么使用 JS 实现元素拖拽功能？</h1><p>要使用 JavaScript 实现元素的拖拽功能，您可以按照以下步骤操作：</p><p>为需要拖拽的元素添加 mousedown、mousemove 和 mouseup 事件监听器。 在 mousedown 事件处理函数中，记录鼠标按下时的位置，以及鼠标相对于元素的位置。 在 mousemove 事件处理函数中，计算鼠标移动的距离，并更新元素的位置。 在 mouseup 事件处理函数中，移除 mousemove 和 mouseup 事件监听器。 以下是一个简单的实现示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Draggable Element&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #draggable &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">            position: absolute;</span><br><span class="line">            cursor: move;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;draggable&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const draggableElement = document.getElementById(&#x27;draggable&#x27;);</span><br><span class="line"></span><br><span class="line">        draggableElement.addEventListener(&#x27;mousedown&#x27;, (event) =&gt; &#123;</span><br><span class="line">            // 记录鼠标按下时的位置</span><br><span class="line">            let startX = event.clientX;</span><br><span class="line">            let startY = event.clientY;</span><br><span class="line"></span><br><span class="line">            // 计算鼠标相对于元素的位置</span><br><span class="line">            let offsetX = startX - draggableElement.offsetLeft;</span><br><span class="line">            let offsetY = startY - draggableElement.offsetTop;</span><br><span class="line"></span><br><span class="line">            // 处理鼠标移动事件</span><br><span class="line">            const onMouseMove = (event) =&gt; &#123;</span><br><span class="line">                // 计算鼠标移动的距离</span><br><span class="line">                let deltaX = event.clientX - startX;</span><br><span class="line">                let deltaY = event.clientY - startY;</span><br><span class="line"></span><br><span class="line">                // 更新元素的位置</span><br><span class="line">                draggableElement.style.left = `$&#123;event.clientX - offsetX&#125;px`;</span><br><span class="line">                draggableElement.style.top = `$&#123;event.clientY - offsetY&#125;px`;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 处理鼠标松开事件</span><br><span class="line">            const onMouseUp = () =&gt; &#123;</span><br><span class="line">                document.removeEventListener(&#x27;mousemove&#x27;, onMouseMove);</span><br><span class="line">                document.removeEventListener(&#x27;mouseup&#x27;, onMouseUp);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 添加事件监听器</span><br><span class="line">            document.addEventListener(&#x27;mousemove&#x27;, onMouseMove);</span><br><span class="line">            document.addEventListener(&#x27;mouseup&#x27;, onMouseUp);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这个示例将实现一个简单的拖拽功能，您可以在此基础上根据需要进行调整和优化。注意，这个示例未考虑边界限制和性能优化，请根据实际需求进行相应调整。</p><h1 id="什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？"><a href="#什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？" class="headerlink" title="什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？"></a>什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？</h1><p>回流（Reflow）和重绘（Repaint）是浏览器渲染过程中的两个关键概念，它们对网页性能产生重要影响。理解回流和重绘以及它们的触发场景有助于我们优化网页性能。</p><p>回流（Reflow）： 回流是当浏览器需要重新计算元素的布局、尺寸和位置时所发生的过程。回流通常发生在以下场景：</p><ol><li>添加或删除可见的 DOM 元素。</li><li>元素尺寸发生变化，如宽度、高度、边距、填充等。</li><li>页面布局发生变化，如改变窗口大小。</li><li>CSS 伪类激活，如:hover。</li><li>计算 offsetWidth、offsetHeight 等属性。</li></ol><p>重绘（Repaint）： 重绘是浏览器在元素的外观发生变化，但不影响布局时所发生的过程。重绘通常发生在以下场景：</p><ol><li>改变元素的颜色、背景、边框等样式，但不影响元素尺寸和位置。减少回流和重绘的方法：</li><li>避免频繁操作样式：多次修改样式时，可以使用一个 class 来修改，或者通过修改 style 属性进行批量操作。</li><li>避免逐项改变样式：使用 CSS 的 transform、opacity 等属性进行动画，而不是改变宽度、高度、位置等会触发回流的属性。</li><li>使用文档片段（DocumentFragment）或者 offscreen 元素进行批量操作：在对 DOM 元素进行大量操作时，可以先将它们从文档流中移除，然后在内存中进行操作，最后再插入文档流中。</li><li>避免使用 table 布局：table 布局中的元素发生回流时，会影响到整个表格，从而导致更多的回流。对具有复杂动画的元素使用绝对定位：将动画元素脱离文档流，减少回流对其他元素的影响。</li><li>避免频繁访问布局信息：如 offsetWidth、offsetHeight 等，可以在访问前将这些值缓存起来，避免多次触发回流。</li></ol><p>回流和重绘对性能影响较大，尤其是在移动设备上。因此，优化代码以减少回流和重绘次数是提高网页性能的重要手段。</p><h1 id="什么是-npm？你用过哪些-npm-包？是否开发过自己的-npm-包？"><a href="#什么是-npm？你用过哪些-npm-包？是否开发过自己的-npm-包？" class="headerlink" title="什么是 npm？你用过哪些 npm 包？是否开发过自己的 npm 包？"></a>什么是 npm？你用过哪些 npm 包？是否开发过自己的 npm 包？</h1><p>npm（Node Package Manager）是一个基于 Node.js 的包管理器，用于管理 Node.js 项目中的依赖和包。npm 提供了一种简单、方便的方式来安装、更新和卸载第三方库和工具，同时还可以用于发布和共享自己开发的包。通过 npm，开发者可以轻松地引入各种库，提高开发效率。</p><p>作为 AI 助手，我不能像人类开发者那样亲自使用和开发 npm 包，但我可以给您提供一些常见的 npm 包：</p><ol><li>express：一个简洁、灵活的 Node.js Web 应用框架，提供了一系列强大的功能来开发 Web 和 API 应用。</li><li>react：一个用于构建用户界面的 JavaScript 库，由 Facebook 开发，广泛应用于前端开发。</li><li>lodash：一个强大的 JavaScript 实用库，提供了许多有用的工具函数，如数组操作、对象操作、函数操作等。</li><li>axios：一个基于 Promise 的 HTTP 客户端库，用于浏览器和 Node.js，提供了简单、易用的 API 来发起 HTTP 请求。</li><li>moment：一个用于解析、处理和显示日期和时间的 JavaScript 库，提供了丰富的 API 来处理各种日期和时间操作。</li><li>nodemon：一个实用的开发工具，用于监视 Node.js 应用程序中的文件更改，并在发生更改时自动重启应用。</li></ol><p>开发自己的 npm 包的过程大致如下：</p><ol><li>创建项目文件夹，并在文件夹中初始化 npm 项目，使用 npm init 命令生成 package.json 文件。</li><li>开发功能模块，确保遵循模块化的原则，编写模块的导出和引入。</li><li>编写详细的 README 文件，说明模块的用途、安装方法、使用方法以及 API 文档。</li><li>确保项目中包含.gitignore 和.npmignore 文件，以排除不需要发布到 npm 的文件和文件夹。</li><li>在 npm 官网（<a href="https://www.npmjs.com/%EF%BC%89%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8%60npm">https://www.npmjs.com/）注册一个账号，然后在命令行中使用`npm</a> login&#96;命令登录。</li><li>使用 npm publish 命令发布包到 npm 仓库。</li></ol><p>发布后，其他开发者可以通过 npm install 命令安装和使用您的包。注意在开发过程中遵循语义化版本规范（Semantic Versioning），便于其他开发者理解版本变更。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么使用-JS-实现元素拖拽功能？&quot;&gt;&lt;a href=&quot;#怎么使用-JS-实现元素拖拽功能？&quot; class=&quot;headerlink&quot; title=&quot;怎么使用 JS 实现元素拖拽功能？&quot;&gt;&lt;/a&gt;怎么使用 JS 实现元素拖拽功能？&lt;/h1&gt;&lt;p&gt;要使用 JavaSc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day24前端面试题</title>
    <link href="http://example.com/2023/03/16/Day24%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/16/Day24%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-16T04:28:19.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说说你对-JS-模块化方案的理解，比如-CommonJS、AMD、CMD、ES-Module-分别是什么？"><a href="#说说你对-JS-模块化方案的理解，比如-CommonJS、AMD、CMD、ES-Module-分别是什么？" class="headerlink" title="说说你对 JS 模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？"></a>说说你对 JS 模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？</h1><p>JS 模块化是指将一个 JS 应用拆分成多个模块或文件，并通过一定的规范或语法定义它们之间的依赖关系，从而达到复用、维护、扩展的目的。常见的 JS 模块化方案有以下几种：</p><ol><li>CommonJS：一种用于服务器端的模块化规范，主要用于 Node.js，它通过 require 来引入模块，通过 module.exports 或 exports 来导出模块。</li><li>AMD：一种用于浏览器端异步加载模块的规范，主要用于 RequireJS，它通过 define 来定义模块，通过 require 来异步加载模块。</li><li>CMD：一种用于浏览器端延迟执行的模块化规范，主要用于 SeaJS，它通过 define 来定义模块，通过 require 来延迟执行模块。</li><li>ES Module：一种官方规范，用于浏览器端和 Node.js 中，通过 import 来引入模块，通过 export 来导出模块。</li></ol><p>这些模块化方案在实现上有不同的语法和规范，但它们都是为了实现 JS 的模块化而产生的，都可以使 JS 应用更易于维护和扩展。</p><p>其中，ES Module 是官方规范，具有更好的兼容性和可扩展性，而 CommonJS 和 AMD&#x2F;CMD 则更多地用于 Node.js 和浏览器端的异步加载，各有优缺点。</p><h1 id="如果使用-Math-random-来计算中奖概率，会有什么问题吗？"><a href="#如果使用-Math-random-来计算中奖概率，会有什么问题吗？" class="headerlink" title="如果使用 Math.random() 来计算中奖概率，会有什么问题吗？"></a>如果使用 Math.random() 来计算中奖概率，会有什么问题吗？</h1><p>使用 Math.random() 来计算中奖概率是不可靠的。因为 Math.random() 函数的随机性并不是真正的随机，它是基于一个种子值（seed）生成的伪随机数序列。如果你在相同的环境中使用相同的种子值，那么生成的随机数序列是相同的。因此，如果不使用合适的种子值生成伪随机数，就有可能出现概率计算错误的情况。</p><p>为了准确地计算中奖概率，可以使用其他的随机数生成算法，比如 crypto 模块中的 randomBytes() 方法，它可以生成真正的随机数。例如，如果要计算 1&#x2F;1000 的中奖概率，可以使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isWinner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rand = crypto.<span class="title function_">randomBytes</span>(<span class="number">4</span>).<span class="title function_">readUInt32BE</span>();</span><br><span class="line">  <span class="keyword">return</span> rand &lt; <span class="number">429496729</span>; <span class="comment">// 429496729 = Math.pow(2, 32) / 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用 crypto.randomBytes() 生成 4 个字节的随机数，然后将它转换为无符号的 32 位整数，判断该随机数是否小于 429496729，如果小于，则认为中奖了。这样计算中奖概率是比较准确的。</p><h1 id="浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？"><a href="#浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？" class="headerlink" title="浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？"></a>浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？</h1><p>浏览器的本地存储方式主要有以下几种：</p><ol><li>Cookie：Cookie 是浏览器中最古老的本地存储方式，它可以存储少量的文本数据，并在之后的 HTTP 请求中自动携带发送给服务器。Cookie 可以设置过期时间，也可以设置作用域（只在特定域名或路径下有效）。 应用场景：一般用于存储会话信息、用户偏好设置等少量的文本数据。</li><li>LocalStorage：LocalStorage 是 HTML5 新增的本地存储方式，可以存储较大量的数据，数据保存在浏览器本地且不会过期，除非手动删除或清除缓存。 应用场景：适用于存储用户个性化数据、本地数据缓存等。</li><li>SessionStorage：SessionStorage 也是 HTML5 新增的本地存储方式，与 LocalStorage 类似，但是数据只在会话期间有效，会话结束或关闭浏览器后数据会被清除。 应用场景：适用于需要短期保存数据的场景，如表单数据暂存、页面数据缓存等。</li><li>IndexedDB：IndexedDB 是 HTML5 中的一个本地数据库存储方案，可以存储大量结构化数据，支持事务处理和索引查找，功能比较强大。 应用场景：适用于需要离线存储数据、本地数据库操作等。</li><li>Web SQL：Web SQL 是 HTML5 中的另一种本地数据库存储方案，采用 SQL 语句进行数据存储和查询，但是目前已经被弃用，不建议使用。 应用场景：类似于 IndexedDB，适用于需要离线存储数据、本地数据库操作等。</li></ol><p>不同的本地存储方式适用于不同的场景，选择合适的方式可以提高用户体验和网站性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说说你对-JS-模块化方案的理解，比如-CommonJS、AMD、CMD、ES-Module-分别是什么？&quot;&gt;&lt;a href=&quot;#说说你对-JS-模块化方案的理解，比如-CommonJS、AMD、CMD、ES-Module-分别是什么？&quot; class=&quot;heade</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day23前端面试题</title>
    <link href="http://example.com/2023/03/16/Day23%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/16/Day23%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-16T04:18:41.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有哪些-CSS-性能优化的操作或技巧？"><a href="#有哪些-CSS-性能优化的操作或技巧？" class="headerlink" title="有哪些 CSS 性能优化的操作或技巧？"></a>有哪些 CSS 性能优化的操作或技巧？</h1><p>以下是一些常用的 CSS 性能优化操作和技巧：</p><ol><li>使用合适的选择器：选择器的复杂度会影响 CSS 渲染性能。尽量使用简单的选择器，避免使用通配符和后代选择器等复杂的选择器。</li><li>避免使用 @import：@import 可以在 CSS 文件中导入其他 CSS 文件，但它会阻塞页面的渲染，影响性能。建议使用 link 标签来引入 CSS 文件。</li><li>避免使用 !important：!important 会影响 CSS 属性的优先级，而且会增加解析和渲染时间。建议尽量避免使用 !important。</li><li>避免使用 inline 样式：inline 样式的优先级最高，但它会增加 HTML 文件的大小，降低页面的加载速度。建议使用外部 CSS 文件和内部样式表。</li><li>压缩和合并 CSS 文件：压缩和合并 CSS 文件可以减小文件大小，提高页面加载速度。可以使用工具例如 CSSMin 和 YUI Compressor 等来进行压缩和合并操作。</li><li>使用 CSS Sprites：CSS Sprites 可以将多个小图片合并成一张大图片，并使用 CSS 来显示不同的部分，减少 HTTP 请求次数，提高页面加载速度。</li><li>避免过度继承：过度继承会导致样式的冗余和继承链的深度增加，影响 CSS 的解析和渲染性能。</li><li>避免使用高消耗的属性和值：某些属性和值的计算成本比较高，例如 box-shadow、border-radius 等，应该尽量避免使用。</li></ol><p>以上是一些常用的 CSS 性能优化操作和技巧，可以帮助提高页面的加载速度和渲染性能。</p><h1 id="JS-在什么情况下会存在数字精度丢失的问题，如何解决？"><a href="#JS-在什么情况下会存在数字精度丢失的问题，如何解决？" class="headerlink" title="JS 在什么情况下会存在数字精度丢失的问题，如何解决？"></a>JS 在什么情况下会存在数字精度丢失的问题，如何解决？</h1><p>在 JavaScript 中，数字类型是采用 IEEE 754 标准的双精度浮点数表示的，由于双精度浮点数只有 52 位精度，因此在进行精度较高的数值计算时，可能会出现数字精度丢失的问题。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 输出结果为 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>可以看到，实际上 0.1 + 0.2 的结果并不等于 0.3，这是因为双精度浮点数的精度限制导致的。在处理货币等需要高精度计算的场景时，这种精度丢失的问题可能会导致计算错误。</p><p>为了解决这个问题，可以采用以下几种方法：</p><ol><li><p>使用整数进行计算：可以将数字转换成整数进行计算，例如将货币的单位从元转换成分进行计算，避免小数计算带来的精度问题。</p></li><li><p>使用第三方库：例如 decimal.js 和 big.js 等第三方库，可以提供更高精度的数字计算功能，避免精度丢失的问题。</p></li><li><p>使用 toFixed 方法：可以使用 JavaScript 中的 toFixed 方法将数字转换成指定位数的字符串，例如将 0.1 和 0.2 转换成一位小数的字符串再进行相加，避免精度丢失的问题。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).<span class="title function_">toFixed</span>(<span class="number">1</span>)); <span class="comment">// 输出结果为 &quot;0.3&quot;</span></span><br></pre></td></tr></table></figure><p>总之，在进行精度较高的数值计算时，需要注意 JavaScript 中存在的数字精度丢失问题，并根据具体情况选择合适的解决方案。</p><h1 id="ES6-中的-Reflect-对象有什么用？"><a href="#ES6-中的-Reflect-对象有什么用？" class="headerlink" title="ES6 中的 Reflect 对象有什么用？"></a>ES6 中的 Reflect 对象有什么用？</h1><p>在 ES6 中，Reflect 对象是一个内置的对象，提供了一组用于操作对象的方法。它的作用是对对象的某些操作进行拦截和修改，从而提供更加灵活和强大的对象操作方式。</p><p>以下是一些 Reflect 对象的常用方法和用途：</p><ol><li>Reflect.get(target, property, receiver)：读取对象的属性值。与对象的点运算符和方括号运算符相比，这个方法提供了更加灵活和可控的属性读取方式。</li><li>Reflect.set(target, property, value, receiver)：设置对象的属性值。与对象的点运算符和方括号运算符相比，这个方法提供了更加灵活和可控的属性设置方式。</li><li>Reflect.has(target, property)：检查对象是否具有指定的属性。与 in 运算符相比，这个方法提供了更加灵活和可控的属性检查方式。</li><li>Reflect.deleteProperty(target, property)：删除对象的属性。与 delete 运算符相比，这个方法提供了更加灵活和可控的属性删除方式。</li><li>Reflect.construct(target, argumentsList[, newTarget])：使用给定的参数列表创建对象。与 new 运算符相比，这个方法提供了更加灵活和可控的对象创建方式。</li><li>Reflect.apply(target, thisArgument, argumentsList)：调用对象的方法。与函数调用运算符相比，这个方法提供了更加灵活和可控的方法调用方式。</li></ol><p>除了上述方法之外，Reflect 对象还提供了许多其他的方法，例如 Reflect.defineProperty、Reflect.getOwnPropertyDescriptor、Reflect.getPrototypeOf、Reflect.setPrototypeOf 等，都可以用于对对象进行拦截和修改。</p><p>总之，Reflect 对象提供了一组灵活和强大的对象操作方法，可以用于实现代理、拦截、元编程等功能，使 JavaScript 更加强大和灵活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有哪些-CSS-性能优化的操作或技巧？&quot;&gt;&lt;a href=&quot;#有哪些-CSS-性能优化的操作或技巧？&quot; class=&quot;headerlink&quot; title=&quot;有哪些 CSS 性能优化的操作或技巧？&quot;&gt;&lt;/a&gt;有哪些 CSS 性能优化的操作或技巧？&lt;/h1&gt;&lt;p&gt;以下</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day22前端面试题</title>
    <link href="http://example.com/2023/03/16/Day22%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/16/Day22%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-16T04:14:59.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-有哪些常用单位？这些单位各有什么区别？"><a href="#CSS-有哪些常用单位？这些单位各有什么区别？" class="headerlink" title="CSS 有哪些常用单位？这些单位各有什么区别？"></a>CSS 有哪些常用单位？这些单位各有什么区别？</h1><p>CSS 中常用的单位有以下几种：</p><ol><li>px（像素）：像素是相对于显示器分辨率而言的，是一个固定的单位。1px 可以被理解为显示器上的一个物理像素点，其大小和颜色由显示器自身控制。</li><li>em（相对长度单位）：em 是相对于父元素的字体大小的单位，当父元素没有设置字体大小时，em 相对于浏览器的默认字体大小。</li><li>rem（相对长度单位）：rem 同样是相对长度单位，但相对于根元素（即 html 元素）的字体大小。</li><li>%（百分比）：百分比是相对于父元素的宽度、高度、字体大小等的百分比。</li><li>vw、vh（视口单位）：vw 和 vh 分别代表视口的宽度和高度的百分比。</li><li>pt（点）：1pt 等于 1&#x2F;72 英寸，常用于打印页面。</li><li>em 和 rem 的区别：em 和 rem 都是相对长度单位，但 em 的大小是相对于其父元素的字体大小，而 rem 的大小则是相对于根元素（即 html 元素）的字体大小。因此，rem 更加稳定，能够更好地控制页面布局和字体大小。</li></ol><p>在使用 CSS 单位时，需要根据实际情况选择合适的单位。一般情况下，像素是最常用的单位，因为它在大多数情况下可以提供良好的显示效果。对于需要在不同设备上适配的情况，可以使用 em、rem 和 vw、vh 等相对单位。</p><h1 id="React-memo-和-useMemo-的用法是什么，有哪些区别？"><a href="#React-memo-和-useMemo-的用法是什么，有哪些区别？" class="headerlink" title="React.memo() 和 useMemo() 的用法是什么，有哪些区别？"></a>React.memo() 和 useMemo() 的用法是什么，有哪些区别？</h1><p>React.memo() 和 useMemo() 是 React 中用于性能优化的两个钩子函数。</p><p>React.memo() 是一个高阶组件，用于优化组件的性能。它会比较组件的新旧 props，如果 props 没有发生改变，则跳过渲染，直接使用上一次渲染的结果。使用 React.memo() 可以避免组件不必要的重新渲染，从而提高应用程序的性能。</p><p>用法示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MemoizedComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">MyComponent</span>);</span><br></pre></td></tr></table></figure><p>useMemo() 是一个 Hook，用于缓存函数的计算结果。它可以缓存组件的 props 或其他数据的计算结果，只有当依赖项发生改变时才重新计算。</p><p>用法示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">computeExpensiveValue</span>(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>区别：</p><ol><li>React.memo() 用于优化组件的性能，它会比较组件的新旧 props，如果 props 没有发生改变，则跳过渲染，直接使用上一次渲染的结果。而 useMemo() 用于缓存函数的计算结果，只有当依赖项发生改变时才重新计算。</li><li>React.memo() 是一个高阶组件，必须包裹组件才能使用，而 useMemo() 是一个 Hook，可以在函数组件中使用。</li></ol><p>综上所述，React.memo() 用于缓存组件的渲染结果，从而提高应用程序的性能，而 useMemo() 则用于缓存函数的计算结果，可以在函数组件中使用。</p><h1 id="什么是-TypeScript-中的命名空间和模块？两者有什么区别？"><a href="#什么是-TypeScript-中的命名空间和模块？两者有什么区别？" class="headerlink" title="什么是 TypeScript 中的命名空间和模块？两者有什么区别？"></a>什么是 TypeScript 中的命名空间和模块？两者有什么区别？</h1><p>在 TypeScript 中，命名空间和模块都是用来组织和管理代码的方式。</p><p>命名空间提供了一种将代码划分为逻辑单元的方式，可以避免命名冲突。在命名空间内，所有变量、函数、类等都是私有的，需要使用 export 关键字进行导出，才能被其他代码使用。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">public name: string</span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块是用来组织和管理代码的方式，与命名空间类似，不同之处在于模块是按文件划分的，一个文件就是一个模块。模块可以使用 export 和 import 关键字来导出和导入代码。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public name: string</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">PI</span>, sayHello, <span class="title class_">Person</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./moduleA&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// Hello, world!</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure><p>命名空间和模块的主要区别在于，命名空间是将代码划分为逻辑单元，而模块是按照文件划分的。在使用模块时，可以使用 import 和 export 进行代码的导入和导出，可以更方便地组织和管理代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-有哪些常用单位？这些单位各有什么区别？&quot;&gt;&lt;a href=&quot;#CSS-有哪些常用单位？这些单位各有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;CSS 有哪些常用单位？这些单位各有什么区别？&quot;&gt;&lt;/a&gt;CSS 有哪些常用单位？这些单位各</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day21前端面试题</title>
    <link href="http://example.com/2023/03/12/Day21%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/12/Day21%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-12T13:06:19.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么使用-CSS3-来实现动画？你实现过哪些动画？"><a href="#怎么使用-CSS3-来实现动画？你实现过哪些动画？" class="headerlink" title="怎么使用 CSS3 来实现动画？你实现过哪些动画？"></a>怎么使用 CSS3 来实现动画？你实现过哪些动画？</h1><p>CSS3 提供了丰富的动画效果，通过使用 CSS3 动画可以实现许多视觉效果，比如旋转、平移、缩放、淡入淡出等。</p><p>CSS3 动画的实现需要使用 @keyframes 规则和 animation 属性，具体的实现步骤如下：</p><p>定义关键帧 使用 @keyframes 规则定义动画关键帧。例如，定义一个旋转动画：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@keyframes spin &#123;</span><br><span class="line">  <span class="keyword">from</span> &#123; <span class="attr">transform</span>: <span class="title function_">rotate</span>(0deg); &#125;</span><br><span class="line">  to &#123; <span class="attr">transform</span>: <span class="title function_">rotate</span>(360deg); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个关键帧定义了从 0 度到 360 度的旋转动画。</p><p>应用动画 使用 animation 属性将动画应用到元素上。例如，将上面定义的 spin 动画应用到一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  <span class="attr">animation</span>: spin 2s linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个样式定义了一个 2 秒线性旋转动画，并且无限循环。</p><p>CSS3 动画的优点在于它不需要使用 JavaScript，可以通过 CSS 代码实现各种复杂的动画效果，并且动画效果比使用 JavaScript 实现的动画效果更加平滑。</p><p>在实际开发中，我们可以使用 CSS3 动画来实现各种动态效果，比如页面切换、元素滚动、菜单展开等。具体实现要根据具体的需求来选择使用哪种动画效果，一些常见的动画效果包括：</p><ol><li>淡入淡出</li><li>旋转</li><li>缩放</li><li>平移</li><li>拉伸</li><li>闪烁 我们可以使用 CSS3 动画来实现这些效果，提高用户体验和交互性。</li></ol><h1 id="如何使用-JS-判断某个字符串长度（要求支持-Emoji-表情）？"><a href="#如何使用-JS-判断某个字符串长度（要求支持-Emoji-表情）？" class="headerlink" title="如何使用 JS 判断某个字符串长度（要求支持 Emoji 表情）？"></a>如何使用 JS 判断某个字符串长度（要求支持 Emoji 表情）？</h1><p>在 JavaScript 中，可以使用 String 类型的 length 属性来获取字符串的长度。但是，由于 Emoji 表情在字符串中占用了两个字符的位置，因此直接使用 length 属性得到的结果并不准确。</p><p>为了正确地获取字符串的长度，可以使用如下的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算字符串的长度（支持 Emoji 表情）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">str</span> - 要计算长度的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; - 字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> code = str.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (code &gt;= <span class="number">0xd800</span> &amp;&amp; code &lt;= <span class="number">0xdbff</span>) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    length++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，对于字符串 “Hello,🌍!”，使用该函数计算出的长度为 8，而使用 length 属性计算出的长度则为 9。</p><h1 id="Vue-Router-路由有哪些模式？各模式有什么区别？"><a href="#Vue-Router-路由有哪些模式？各模式有什么区别？" class="headerlink" title="Vue Router 路由有哪些模式？各模式有什么区别？"></a>Vue Router 路由有哪些模式？各模式有什么区别？</h1><p>Vue Router 路由有三种模式：</p><ol><li>hash 模式：使用 URL 中的 hash（即 # 后面的内容）来作为路由路径。这种模式下，页面不会重新加载，只会更新 hash 值，并触发路由变化，从而渲染对应的组件。</li><li>history 模式：使用 HTML5 中新增的 History API 来管理浏览历史记录，从而实现页面的前进和后退。在这种模式下，URL 中不会带有 # 号，而是使用真实的 URL 路径来作为路由路径。</li><li>abstract 模式：在不需要基于浏览器的 API 时，可以使用这种模式。在这种模式下，路由器并不会监听 URL 变化，而是通过调用 router.replace 或 router.push 来进行导航。</li></ol><p>区别：</p><ol><li>hash 模式可以兼容较老的浏览器，但 URL 中会带有 # 号。</li><li>history 模式无需带有 # 号，更加美观，但需要后端支持，否则刷新页面会导致 404 错误。</li><li>abstract 模式主要用于一些特定场景，例如在使用 Node.js 时，可以使用 abstract 模式来构建路由。</li></ol><p>一般来说，如果需要支持较老的浏览器，或者不需要后端支持，可以使用 hash 模式；否则建议使用 history 模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么使用-CSS3-来实现动画？你实现过哪些动画？&quot;&gt;&lt;a href=&quot;#怎么使用-CSS3-来实现动画？你实现过哪些动画？&quot; class=&quot;headerlink&quot; title=&quot;怎么使用 CSS3 来实现动画？你实现过哪些动画？&quot;&gt;&lt;/a&gt;怎么使用 CSS3 来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day20前端面试题</title>
    <link href="http://example.com/2023/03/11/Day20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/11/Day20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-11T08:24:47.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-代码中的-use-strict-是什么？有什么作用？"><a href="#JS-代码中的-use-strict-是什么？有什么作用？" class="headerlink" title="JS 代码中的 use strict 是什么？有什么作用？"></a>JS 代码中的 use strict 是什么？有什么作用？</h1><p>“use strict” 是 ECMAScript 5 引入的一种严格模式，它用于指示 JavaScript 引擎采用更严格的解析和执行模式。</p><p>当在 JavaScript 代码中使用 “use strict” 声明时，代码将会在严格模式下执行。严格模式包含了一些额外的规则和限制，有助于开发者避免一些常见的错误。</p><p>使用 “use strict” 的主要作用包括：</p><ol><li>消除 JavaScript 中的一些不合理、不安全的语法，减少代码出错的可能性。</li><li>防止使用未声明的变量、函数，强制开发者进行声明。</li><li>强制函数中的 this 值只能在函数内部使用，避免在全局作用域中误用 this 值。</li><li>禁止删除变量、函数等，避免意外删除重要的变量和函数。</li><li>提高代码性能，因为 JavaScript 引擎可以更好地进行优化。</li></ol><p>使用 “use strict” 的方式有两种：</p><ol><li>在 JavaScript 文件开头使用 “use strict”。</li><li>在函数体内第一条语句中使用 “use strict”。</li></ol><p>例如，在 JavaScript 文件开头使用 “use strict” 的方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在函数体内第一条语句中使用 “use strict” 的方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，”use strict” 是一种在 JavaScript 中使用严格模式的方法，它可以提高代码的可靠性和性能，避免一些常见的错误。</p><h1 id="什么是前后端分离？它有什么优点和缺点？"><a href="#什么是前后端分离？它有什么优点和缺点？" class="headerlink" title="什么是前后端分离？它有什么优点和缺点？"></a>什么是前后端分离？它有什么优点和缺点？</h1><p>前后端分离是指将前端和后端分别进行独立开发和部署。使前端和后端分别由不同的开发团队负责，通过 API 接口进行数据交互。前端负责页面展示和用户交互，后端负责业务逻辑和数据存储，两者通过 API 进行通信。</p><p>前后端分离的优点包括：</p><ol><li>分工明确：前端和后端分别由不同的开发团队负责，各司其职，有利于开发流程的管理和控制。</li><li>前后端解耦：前后端分离可以使前端和后端解耦，前端只关注页面展示和用户交互，后端只关注业务逻辑和数据存储，有利于模块化开发和维护。</li><li>更好的性能和用户体验：前后端分离可以使前端采用现代化的前端框架和技术，提高网站的性能和用户体验。</li><li>更好的可扩展性：前后端分离可以使后端提供更丰富的 API，方便前端进行开发和维护，同时也使得后端更易于扩展和修改。</li></ol><p>前后端分离的缺点包括：</p><ol><li>开发难度增加：前后端分离需要前端和后端分别进行开发，需要更多的协调和沟通，开发难度增加。</li><li>维护难度增加：前后端分离使得前端和后端的代码分离，需要分别进行维护，维护难度增加。</li><li>安全问题：前后端分离可能会导致一些安全问题，例如跨站点脚本攻击（XSS）和跨站点请求伪造（CSRF），需要采取相应的安全措施来解决。<br>总之，前后端分离有其优点和缺点。前后端分离可以提高开发效率、网站性能和用户体验，但也可能会增加开发和维护的难度，需要采取相应的措施来解决。</li></ol><h1 id="前端性能优化指标有哪些？怎么进行性能检测？"><a href="#前端性能优化指标有哪些？怎么进行性能检测？" class="headerlink" title="前端性能优化指标有哪些？怎么进行性能检测？"></a>前端性能优化指标有哪些？怎么进行性能检测？</h1><p>前端性能优化主要是通过一系列技术手段和优化策略来提升网站或应用的性能，从而提高用户的体验。下面列举一些常见的前端性能优化的指标和性能检测的方法：</p><ol><li>加载速度：网站或应用的加载速度是用户体验的重要因素。可以使用工具（如 WebPagetest、PageSpeed Insights）来测试网站或应用的加载速度，并通过优化图片大小、减少 HTTP 请求、使用浏览器缓存等方式来提升加载速度。</li><li>渲染速度：渲染速度是指页面加载完成后页面内容渲染的速度。可以使用 Chrome 开发者工具中的 Performance 面板来检测页面渲染速度，并通过减少 DOM 操作、使用 CSS3 动画、减少 JavaScript 的执行时间等方式来提升渲染速度。</li><li>响应速度：响应速度是指网站或应用处理请求的速度。可以使用工具（如 Pingdom、GTmetrix）来测试响应速度，并通过优化服务器响应时间、压缩 JavaScript 和 CSS 文件等方式来提升响应速度。</li><li>可访问性：可访问性是指网站或应用是否易于使用和访问。可以通过使用 HTML5、WAI-ARIA 标准、有意义的网页标题、有意义的链接等方式来提高可访问性。</li><li>移动端性能：随着移动设备的普及，移动端性能越来越重要。可以使用工具（如 Google Mobile-Friendly Test）来测试移动端性能，并通过使用响应式设计、优化图片和视频大小、使用 viewport meta 标签等方式来提高移动端性能。</li></ol><p>总结：前端性能优化指标包括加载速度、渲染速度、响应速度、可访问性和移动端性能等方面。可以使用各种工具来检测这些指标，并采取相应的优化策略来提高网站或应用的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-代码中的-use-strict-是什么？有什么作用？&quot;&gt;&lt;a href=&quot;#JS-代码中的-use-strict-是什么？有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;JS 代码中的 use strict 是什么？有什么作用？&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day19前端面试题</title>
    <link href="http://example.com/2023/03/10/Day19%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/10/Day19%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-10T07:46:22.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么-JS-要被设计为单线程？"><a href="#为什么-JS-要被设计为单线程？" class="headerlink" title="为什么 JS 要被设计为单线程？"></a>为什么 JS 要被设计为单线程？</h1><p>JS 被设计为单线程的主要原因是为了避免多线程编程所带来的复杂性。如果 JS 是多线程的，那么在处理并发问题时，需要考虑锁、同步等一系列复杂的问题，这会增加代码的复杂度和开发难度。</p><p>此外，JS 最初是为了解决网页交互的问题而诞生的，而网页交互的需求大部分是基于用户事件的，比如点击按钮、输入文本等。这些操作的响应速度要求很高，如果在响应事件的同时还要处理其他任务，可能会导致网页卡顿、响应变慢等用户体验不佳的问题。</p><p>因此，为了避免多线程所带来的复杂性和降低开发难度，并且满足网页交互的高响应速度需求，JS 被设计为单线程。虽然单线程有局限性，但是可以通过异步编程、事件循环机制等技术手段来实现高效的并发处理。</p><h1 id="TypeScript-中的-Declare-关键字有什么用？"><a href="#TypeScript-中的-Declare-关键字有什么用？" class="headerlink" title="TypeScript 中的 Declare 关键字有什么用？"></a>TypeScript 中的 Declare 关键字有什么用？</h1><p>TypeScript 中的 declare 关键字用于声明一个变量、函数、类等的类型信息，但不实现其具体实现。它主要用于在编译时进行静态类型检查，并在编译后移除声明的代码，以减少 JavaScript 文件的大小。</p><p>使用 declare 关键字声明的类型信息可以是任何类型，如对象、函数、类、变量、命名空间等。常见的使用场景有：</p><p>声明全局变量或模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量</span></span><br><span class="line">declare <span class="keyword">const</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: string</span>) =&gt;</span> any;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明模块</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&quot;lodash&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn: <span class="built_in">Function</span>, wait: number</span>): <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明外部的 JavaScript 库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&quot;some-library&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>): <span class="keyword">void</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">someVariable</span>: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明命名空间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare namespace <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 declare 关键字，可以让 TypeScript 在编译时检查代码的类型信息，并避免一些类型错误。同时，也可以提高代码的可读性和维护性。</p><h1 id="什么是-Node-js-中的-process？它有哪些方法和应用场景？"><a href="#什么是-Node-js-中的-process？它有哪些方法和应用场景？" class="headerlink" title="什么是 Node.js 中的 process？它有哪些方法和应用场景？"></a>什么是 Node.js 中的 process？它有哪些方法和应用场景？</h1><p>在 Node.js 中，process 是一个全局变量，它提供了与当前 Node.js 进程相关的信息和控制。process 对象是 EventEmitter 的一个实例，因此它可以使用 EventEmitter 的 API，例如注册事件监听器和触发事件。</p><p>process 对象的一些常用方法和属性：</p><ol><li>process.argv：返回一个数组，其中包含命令行参数。第一个元素是 Node.js 可执行文件的路径，第二个元素是正在执行的 JavaScript 文件的路径，后面的元素是命令行参数。</li><li>process.env：返回一个包含当前 Shell 环境变量的对象。</li><li>process.exit([code])：终止 Node.js 进程。如果指定了 code，那么进程将以 code 退出。</li><li>process.cwd()：返回当前工作目录的路径。</li><li>process.chdir(directory)：将 Node.js 进程的工作目录更改为 directory。</li><li>process.pid：返回 Node.js 进程的进程 ID。</li><li>process.nextTick(callback[, arg1][, arg2][, …])：将 callback 添加到下一个 tick 队列。callback 会在当前操作完成后、事件循环继续之前调用。</li><li>process.on(event, listener)：注册事件监听器。常用的事件包括 “exit”、”uncaughtException”、”SIGINT” 等。</li></ol><p>process 对象的应用场景：</p><ol><li>监听进程退出事件，执行资源清理操作。</li><li>通过 process.argv 读取命令行参数。</li><li>通过 process.env 读取环境变量。</li><li>通过 process.cwd 和 process.chdir 修改 Node.js 进程的工作目录。</li><li>通过 process.pid 获取进程 ID。</li><li>通过 process.nextTick 将某个操作放到下一个 tick 队列中，以实现异步执行。</li></ol><p>总之，process 对象提供了与 Node.js 进程相关的许多信息和控制，是 Node.js 编程中不可或缺的一部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么-JS-要被设计为单线程？&quot;&gt;&lt;a href=&quot;#为什么-JS-要被设计为单线程？&quot; class=&quot;headerlink&quot; title=&quot;为什么 JS 要被设计为单线程？&quot;&gt;&lt;/a&gt;为什么 JS 要被设计为单线程？&lt;/h1&gt;&lt;p&gt;JS 被设计为单线程的主要原</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day18前端面试题</title>
    <link href="http://example.com/2023/03/09/Day18%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/09/Day18%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-09T09:01:05.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router-的-route-和-router-对象有什么区别？"><a href="#Vue-Router-的-route-和-router-对象有什么区别？" class="headerlink" title="Vue Router 的 $route 和 $router 对象有什么区别？"></a>Vue Router 的 $route 和 $router 对象有什么区别？</h1><p>在 Vue.js 中，$route 和 $router 都是 Vue Router 提供的对象，但它们的作用不同。</p><p>$route 对象代表着当前激活的路由信息，它包含了当前 URL 解析得到的信息，如当前路径、参数、查询参数等。$route 对象是一个只读对象，我们无法通过改变 $route 对象来改变当前路由。</p><p>$router 对象则是 Vue Router 的实例对象，它负责管理整个路由的状态，包括当前路径、路由参数、路由切换等。$router 对象可以通过编程的方式来改变当前路由，如通过 $router.push()、$router.replace()、$router.go() 等方法。</p><p>总的来说，$route 对象是获取当前路由信息的方式，$router 对象则是控制当前路由状态的方式。</p><h1 id="介绍下从-HTTP-x2F-1-0、HTTP-x2F-1-1-到-HTTP-x2F-2-再到-HTTP-x2F-3-的演化过程，各个阶段相对前一阶段做了哪些优化"><a href="#介绍下从-HTTP-x2F-1-0、HTTP-x2F-1-1-到-HTTP-x2F-2-再到-HTTP-x2F-3-的演化过程，各个阶段相对前一阶段做了哪些优化" class="headerlink" title="介绍下从 HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程，各个阶段相对前一阶段做了哪些优化"></a>介绍下从 HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程，各个阶段相对前一阶段做了哪些优化</h1><p>HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程主要是为了解决 HTTP 协议在网络传输过程中出现的一些问题，提高网络传输效率和性能。</p><p>HTTP&#x2F;1.0 是最早的 HTTP 协议，它使用一条长连接（keep-alive）传输一个请求和响应，存在以下问题：</p><ol><li>队头阻塞问题：因为只有一个连接，所以如果有一个请求被阻塞，后续请求也会被阻塞。</li><li>无法多路复用：只能按顺序传输一个请求和响应，无法同时传输多个请求和响应。</li><li>每次请求需要新建连接：每次请求都需要新建连接，连接的建立和关闭过程会消耗时间。</li></ol><p>HTTP&#x2F;1.1 引入了以下优化：</p><ol><li>持久连接：即连接重用，通过一个 TCP 连接传输多个请求和响应，减少了连接建立和关闭的时间。</li><li>分块传输编码（chunked）：把响应数据分成多个块，每个块前面加上长度信息，便于客户端逐步接收。</li><li>虚拟主机（Virtual Host）：通过在请求头中添加 Host 字段来区分不同的主机。</li></ol><p>HTTP&#x2F;2 引入了以下优化：</p><ol><li>多路复用：允许同时通过同一个连接并行传输多个请求和响应，解决了队头阻塞问题。</li><li>二进制分帧：将传输的数据分成一个个二进制帧，每个帧都有自己的 ID，可以独立传输，解决了队头阻塞问题，提高了传输效率。</li><li>头部压缩：使用 HPACK 算法对头部信息进行压缩，减少了头部信息的传输量。</li></ol><p>HTTP&#x2F;3 引入了以下优化：</p><ol><li>QUIC 协议：使用 QUIC 协议替代 TCP，支持更快的连接建立和更快的重传，能够解决 TCP 队头阻塞和 TCP 握手延迟的问题。</li><li>数据流分离：将一个连接分成多个数据流，每个数据流都有独立的 ID，可以独立控制和传输数据。</li></ol><p>总的来说，HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程主要是从连接的角度进行了优化，提高了并发能力和传输效率，提高了用户体验。</p><h1 id="什么是-CSS-工程化？你用过哪些相关的工具？"><a href="#什么是-CSS-工程化？你用过哪些相关的工具？" class="headerlink" title="什么是 CSS 工程化？你用过哪些相关的工具？"></a>什么是 CSS 工程化？你用过哪些相关的工具？</h1><p>CSS 工程化是指将 CSS 在项目中进行模块化、组件化、可维护性、可重用性等方面的处理，以达到工程化管理 CSS 的目的。</p><p>在 CSS 工程化中，通常会使用一些相关的工具来辅助管理 CSS，常用的工具包括：</p><ol><li>CSS 预处理器：如 Sass、Less、Stylus 等，可以通过变量、函数、混合等方式，提高 CSS 的可维护性和可重用性。</li><li>CSS 后处理器：如 PostCSS，可以用来处理 CSS 代码，通过插件的形式可以实现一些自动化处理，如自动添加前缀、压缩 CSS 等。</li><li>CSS 模块化工具：如 CSS Modules、styled-components 等，可以将 CSS 样式与组件代码结合在一起，提高 CSS 的可维护性和可重用性。</li><li>CSS 命名规范：如 BEM、SMACSS、OOCSS 等，可以通过规范化 CSS 的命名方式，提高 CSS 的可读性和可维护性。</li></ol><p>通过使用这些工具，可以提高 CSS 的可维护性、可重用性和可读性，从而使得前端开发更加高效、简洁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-Router-的-route-和-router-对象有什么区别？&quot;&gt;&lt;a href=&quot;#Vue-Router-的-route-和-router-对象有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;Vue Router 的 $route </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day17前端面试题</title>
    <link href="http://example.com/2023/03/08/Day17%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/08/Day17%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-08T02:08:35.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？"><a href="#什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？" class="headerlink" title="什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？"></a>什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？</h1><p>前端路由是指在前端页面内部实现页面之间的跳转，而不是像传统的网页跳转那样在后端进行页面跳转。前端路由使用浏览器的 history 接口，通过改变浏览器的 URL，来更新页面的视图。</p><p>前端路由适合用于单页面应用（SPA）的开发。当一个应用中需要经常切换页面时，使用前端路由可以避免频繁向服务器发起请求，提高页面切换的速度和用户体验。</p><p>前端路由的优点：</p><ol><li>单页面应用的页面跳转速度快，用户体验好</li><li>可以根据不同的 URL 显示不同的页面内容，可以更好地实现前端的页面控制</li><li>可以更好地实现前端路由权限控制</li></ol><p>前端路由的缺点：</p><ol><li>不支持搜索引擎爬虫，对于 SEO 不利</li><li>对于复杂的页面控制逻辑和状态管理，需要额外的工作</li><li>需要注意浏览器的前进后退等操作对页面的影响</li></ol><p>总的来说，前端路由适用于对页面跳转速度和用户体验有要求的单页面应用，但在一些场景下，需要权衡其带来的一些缺点。</p><h1 id="怎么解决跨域问题？"><a href="#怎么解决跨域问题？" class="headerlink" title="怎么解决跨域问题？"></a>怎么解决跨域问题？</h1><p>跨域问题（Cross-Origin Resource Sharing，CORS）是由于浏览器的同源策略（Same-Origin Policy）导致的。同源策略指的是，如果两个 URL 的协议、主机名和端口号都相同，那么它们就是同源的，否则就是跨域的。当网页发起跨域请求时，浏览器会根据同源策略限制请求。解决跨域问题的方法有以下几种：</p><p>JSONP（JSON with Padding）</p><p>JSONP 是一种跨域请求数据的方式，它利用了 &lt;**script**&gt; 标签不受同源策略限制的特性，可以从不同的域名请求数据。实现原理是在服务端生成一个 JavaScript 函数，客户端使用 &lt;**script**&gt; 标签请求该函数，服务端返回该函数的调用，并将需要传输的数据作为函数参数传入。</p><p>CORS（Cross-Origin Resource Sharing）</p><p>CORS 是一种通过添加一些 HTTP 头来允许浏览器跨域访问资源的机制，主要是服务端配置。服务端需要在响应头中添加 Access-Control-Allow-Origin 和其他一些参数，指示允许哪些域名进行跨域请求。</p><p>反向代理</p><p>反向代理是将客户端的请求转发到真正的服务端，从而解决跨域问题。反向代理服务器和真正的服务端在同一个域名下，客户端的请求只需要向反向代理服务器发起，由反向代理服务器将请求转发到真正的服务端，最后将响应返回给客户端。</p><p>WebSocket</p><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，可以用于跨域通信。由于 WebSocket 协议并不受同源策略的限制，因此可以实现跨域通信。</p><p>总的来说，不同的解决方案有各自的优缺点，应根据实际情况选择最适合的方式。例如，如果需要在客户端和服务端之间进行实时通信，WebSocket 是最佳选择；如果只需要在客户端发起简单的 GET 请求，可以使用 JSONP 等方式。</p><h1 id="什么是-Vuex？使用-Vuex-有哪些好处？"><a href="#什么是-Vuex？使用-Vuex-有哪些好处？" class="headerlink" title="什么是 Vuex？使用 Vuex 有哪些好处？"></a>什么是 Vuex？使用 Vuex 有哪些好处？</h1><p>Vuex 是 Vue.js 框架中用于实现集中式状态管理的插件。它的主要作用是在多个组件之间共享状态，并且提供了一些工具来方便地管理应用程序的状态。</p><p>使用 Vuex 可以将应用程序的状态存储在一个集中的地方，从而使状态管理更加容易、可维护性更高。它还提供了一些工具来简化状态的更改和操作，例如：在组件中使用 mutations 来修改状态，或者使用 actions 来异步操作数据。</p><p>使用 Vuex 的好处包括：</p><ol><li>集中化的状态管理：将应用程序的状态集中存储在一个地方，可以方便地进行状态管理和维护。</li><li>易于调试：使用 Vuex 可以方便地跟踪和记录状态的更改历史，有助于快速诊断和解决问题。</li><li>状态共享：在多个组件之间共享状态，避免了组件之间繁琐的传值，提高了组件之间的解耦性。</li><li>插件化：Vuex 提供了插件机制，可以方便地扩展和自定义 Vuex 的功能。</li></ol><p>Vuex 的缺点包括：</p><ol><li>增加了学习成本：Vuex 相对于直接在组件中管理状态来说，增加了一些学习成本，需要花费时间去学习 Vuex 的概念和使用方式。</li><li>增加了代码复杂度：在使用 Vuex 的过程中，需要增加一些额外的代码来管理状态，有时可能会增加代码的复杂度。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？&quot;&gt;&lt;a href=&quot;#什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？&quot; class=&quot;headerlink&quot; title=&quot;什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day16前端面试题</title>
    <link href="http://example.com/2023/03/08/Day16%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/08/Day16%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-08T02:05:50.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是箭头函数？能使用-new-来创建箭头函数么？"><a href="#什么是箭头函数？能使用-new-来创建箭头函数么？" class="headerlink" title="什么是箭头函数？能使用 new 来创建箭头函数么？"></a>什么是箭头函数？能使用 new 来创建箭头函数么？</h1><p>箭头函数是 ES6 中新增的一种函数定义方式，可以用来简化函数的定义和书写。箭头函数的特点是：简洁的语法、绑定 this 关键字、不能用作构造函数。</p><p>箭头函数使用箭头（&#x3D;&gt;）来定义，基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) =&gt; &#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，parameters 是函数的参数列表，可以是一个或多个参数，多个参数之间用逗号分隔；statements 是函数的执行语句，可以是一个或多个语句，多个语句之间用花括号包裹起来。</p><p>在箭头函数中，this 关键字指向的是函数定义时所在的对象，而不是执行时所在的对象。这个特性有助于避免 this 的指向问题，使得代码更加简洁易读。</p><p>需要注意的是，箭头函数不能用作构造函数，也就是不能通过 new 关键字来创建实例。因为箭头函数没有自己的 this，而是继承了外层作用域的 this。如果用 new 来创建实例，就会出现意料之外的结果。</p><h1 id="什么是-webpack-的热更新？它的实现原理是什么？"><a href="#什么是-webpack-的热更新？它的实现原理是什么？" class="headerlink" title="什么是 webpack 的热更新？它的实现原理是什么？"></a>什么是 webpack 的热更新？它的实现原理是什么？</h1><p>webpack 的热更新（Hot Module Replacement，简称 HMR）是一种开发时提高开发效率的技术，可以实现无需刷新页面即可看到代码修改后的效果。在使用 HMR 后，当修改了代码后，webpack 只会重新编译修改的代码，并将新的模块发送到客户端，替换掉旧的模块，从而达到实时更新页面的目的。</p><p>实现 HMR 的关键是在客户端和服务器端之间建立一个 WebSocket 连接，当代码发生变化时，服务器端会将新的模块发送给客户端，客户端接收到新的模块后会用新模块替换旧模块，从而实现实时更新。</p><p>具体来说，webpack HMR 主要分为以下几个步骤：</p><ol><li>启动 webpack-dev-server，配置 HMR 插件</li><li>当代码变化时，webpack-dev-server 会编译出新的模块</li><li>HMR runtime（客户端运行时）会通过 WebSocket 与服务器通信，获取最新的模块</li><li>当 HMR runtime 接收到新模块时，会将新模块加载到浏览器中，并通过模块热替换算法将新模块与旧模块进行比较，只替换有变化的模块部分</li><li>页面更新完成，无需刷新页面即可看到最新的效果。</li></ol><p>总之，HMR 可以大大提高开发效率，同时也能够减少代码变更时的刷新操作，提高开发体验。</p><h1 id="说说常规的前端性能优化手段"><a href="#说说常规的前端性能优化手段" class="headerlink" title="说说常规的前端性能优化手段"></a>说说常规的前端性能优化手段</h1><p>前端性能优化是一个重要的工作，可以有效地提升用户的体验和网站的访问速度。以下是一些常规的前端性能优化手段：</p><ol><li>减少 HTTP 请求：合并文件、使用 CSS 精灵、减小图片大小等。</li><li>压缩文件：使用压缩工具压缩 HTML、CSS、JavaScript、图片等文件大小。</li><li>缓存：使用缓存来减少网络请求。</li><li>懒加载：图片或者资源在真正需要的时候再加载，可以有效减少页面加载时间。</li><li>静态资源 CDN 加速：利用 CDN 分发静态资源，减少服务器压力，提高网站的访问速度。</li><li>减少 DOM 操作：DOM 操作是很耗费性能的，所以要尽量减少 DOM 操作的次数，尽量使用批量操作。</li><li>使用 CSS3 动画：使用 CSS3 动画而不是 JavaScript 动画，因为 CSS3 动画的性能更优。</li><li>使用字体图标：使用字体图标可以减少图片的请求，提高页面性能。</li><li>去除不必要的插件：移除不必要的插件可以提高页面加载速度，减少不必要的代码。</li><li>图片优化：对图片进行压缩和优化，减少图片的大小和请求次数。</li></ol><p>以上是一些常规的前端性能优化手段，可以根据实际项目情况选择适合的优化手段来提高页面性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是箭头函数？能使用-new-来创建箭头函数么？&quot;&gt;&lt;a href=&quot;#什么是箭头函数？能使用-new-来创建箭头函数么？&quot; class=&quot;headerlink&quot; title=&quot;什么是箭头函数？能使用 new 来创建箭头函数么？&quot;&gt;&lt;/a&gt;什么是箭头函数？能使用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day15前端面试题</title>
    <link href="http://example.com/2023/03/06/Day15%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/06/Day15%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-06T01:18:50.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-HTML-语义化？为什么要语义化？"><a href="#什么是-HTML-语义化？为什么要语义化？" class="headerlink" title="什么是 HTML 语义化？为什么要语义化？"></a>什么是 HTML 语义化？为什么要语义化？</h1><p>HTML 语义化是指在编写 HTML 代码时，使用具有含义的标签来描述页面内容的结构和意义，而不是只关注页面的表现形式。比如使用 &lt;**header**&gt; 标签来表示页面头部，使用 &lt;**nav**&gt; 标签来表示页面导航，使用 &lt;**article**&gt; 标签来表示文章内容等。</p><p>HTML 语义化的目的在于增强页面的可读性和可维护性，使得开发人员和搜索引擎更容易理解页面的结构和内容。此外，语义化的 HTML 代码也更符合无障碍标准，使得视力受限的用户等特定人群能够更方便地访问页面。</p><p>除此之外，语义化的 HTML 代码还有利于 SEO（搜索引擎优化），可以使得搜索引擎更好地抓取页面内容，提高网站在搜索引擎中的排名。</p><p>综上所述，HTML 语义化可以使得页面更易读、易维护、易访问和易优化。</p><h1 id="怎么用-JS-实现大型文件上传？要考虑哪些问题？"><a href="#怎么用-JS-实现大型文件上传？要考虑哪些问题？" class="headerlink" title="怎么用 JS 实现大型文件上传？要考虑哪些问题？"></a>怎么用 JS 实现大型文件上传？要考虑哪些问题？</h1><p>在前端实现大型文件上传，需要考虑以下几个问题：</p><p>分片上传：将大文件切割成多个小块进行上传，可以避免一次性上传大文件导致的上传时间过长，网络中断等问题。通常情况下，每个块大小为 1MB 左右。</p><p>断点续传：由于网络等因素，上传过程中可能出现中断，此时需要能够从中断的地方恢复上传。</p><p>并发上传：多个文件同时上传，需要对上传队列进行管理，保证上传速度和顺序。</p><p>上传进度显示：及时显示上传进度，让用户知道上传进度和状态。</p><p>可以通过使用第三方库来实现大型文件上传，比如 Plupload、Resumable.js 等。</p><p>以下是一个使用 Plupload 实现大型文件上传的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 <span class="title class_">Plupload</span> 的 <span class="title class_">JavaScript</span> 和 <span class="variable constant_">CSS</span> 文件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;plupload.full.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;plupload.css&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 上传控件的容器 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;uploader&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn&#x27;t have Flash, Silverlight or HTML5 support.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 初始化上传控件 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> uploader = <span class="keyword">new</span> plupload.<span class="title class_">Uploader</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">browse_button</span>: <span class="string">&#x27;uploader&#x27;</span>, <span class="comment">// 上传控件的容器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">url</span>: <span class="string">&#x27;/upload&#x27;</span>, <span class="comment">// 上传文件的 URL</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">multi_selection</span>: <span class="literal">false</span>, <span class="comment">// 是否允许同时上传多个文件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">filters</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">max_file_size</span>: <span class="string">&#x27;100mb&#x27;</span>, <span class="comment">// 最大上传文件大小</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">mime_types</span>: [</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123; <span class="attr">title</span>: <span class="string">&#x27;Image files&#x27;</span>, <span class="attr">extensions</span>: <span class="string">&#x27;jpg,jpeg,gif,png&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123; <span class="attr">title</span>: <span class="string">&#x27;Zip files&#x27;</span>, <span class="attr">extensions</span>: <span class="string">&#x27;zip,rar&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      ]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">init</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 添加文件到上传队列之前触发的事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">BeforeUpload</span>: <span class="keyword">function</span> (<span class="params">up, file</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BeforeUpload:&#x27;</span>, file.<span class="property">name</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 开始上传文件时触发的事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">UploadFile</span>: <span class="keyword">function</span> (<span class="params">up, file</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;UploadFile:&#x27;</span>, file.<span class="property">name</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 上传进度改变时触发的事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">UploadProgress</span>: <span class="keyword">function</span> (<span class="params">up, file</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;UploadProgress:&#x27;</span>, file.<span class="property">percent</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 上传成功时触发的事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">FileUploaded</span>: <span class="keyword">function</span> (<span class="params">up, file, info</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;FileUploaded:&#x27;</span>, file.<span class="property">name</span>, info.<span class="property">response</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 上传出错时触发的事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">Error</span>: <span class="keyword">function</span> (<span class="params">up, err</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error:&#x27;</span>, err.<span class="property">message</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 初始化上传控件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  uploader.<span class="title function_">init</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在后端，需要根据上传控件发送的请求，来实现文件的接收和存储。具体实现方式视具体情况而定，可以使用 SpringMVC、Express.js 等框架来实现。同时，也需要考虑上传文件大小限制、上传速度控制等问题。</p><h1 id="如何提高-webpack-的打包速度？"><a href="#如何提高-webpack-的打包速度？" class="headerlink" title="如何提高 webpack 的打包速度？"></a>如何提高 webpack 的打包速度？</h1><p>Webpack 的打包速度受多个因素影响，以下是一些提高打包速度的方法：</p><ol><li>升级 webpack 版本：Webpack 不断更新优化打包速度，升级到最新版本可以获得更好的性能。</li><li>使用更快的文件系统：使用更快的文件系统（如 RAM 磁盘）可以提高读写速度，加快 webpack 打包速度。</li><li>减少文件搜索范围：在 Webpack 的配置中指定更少的文件搜索路径，可以减少文件搜索的范围，提高打包速度。</li><li>使用 loader 缓存：Webpack 的 loader 会缓存处理后的结果，加快下次打包的速度。可以使用 cache-loader 和 hard-source-webpack-plugin 等插件来进一步优化 loader 的缓存。</li><li>拆分代码块：将代码拆分为更小的代码块，可以减少打包时间。可以使用 Webpack 的 code splitting 功能或手动将代码拆分为多个文件。</li><li>避免不必要的插件和 loader：减少不必要的插件和 loader 可以减少打包时间。</li><li>使用 Happypack：Happypack 可以将 Webpack 的 loader 转换为多线程模式，加快打包速度。</li><li>启用 Tree Shaking：Tree Shaking 可以排除未使用的代码，减少打包大小，加快打包速度。</li></ol><p>总之，提高 webpack 打包速度需要从多个方面综合考虑，需要不断进行尝试和优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-HTML-语义化？为什么要语义化？&quot;&gt;&lt;a href=&quot;#什么是-HTML-语义化？为什么要语义化？&quot; class=&quot;headerlink&quot; title=&quot;什么是 HTML 语义化？为什么要语义化？&quot;&gt;&lt;/a&gt;什么是 HTML 语义化？为什么要语义化？&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day14前端面试题</title>
    <link href="http://example.com/2023/03/05/Day14%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/05/Day14%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-05T11:19:59.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-如何顺序执行-10-个异步任务？"><a href="#JS-如何顺序执行-10-个异步任务？" class="headerlink" title="JS 如何顺序执行 10 个异步任务？"></a>JS 如何顺序执行 10 个异步任务？</h1><p>JS 中可以使用 Promise 和 async&#x2F;await 来顺序执行异步任务。</p><p>使用 Promise 可以通过 then() 方法的链式调用来实现顺序执行异步任务，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Async task 1&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Async task 2&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序执行异步任务</span></span><br><span class="line"><span class="title function_">asyncTask1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">asyncTask2</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行完异步任务1和异步任务2后的逻辑</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>使用 async&#x2F;await 可以将异步任务看作同步代码来执行，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runAsyncTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncTask1</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncTask2</span>();</span><br><span class="line">  <span class="comment">// 执行完异步任务1和异步任务2后的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runAsyncTasks</span>();</span><br></pre></td></tr></table></figure><p>在这里，runAsyncTasks() 函数会先执行异步任务 1，等待异步任务 1 完成后再执行异步任务 2。</p><h1 id="React-组件间怎么进行通信？"><a href="#React-组件间怎么进行通信？" class="headerlink" title="React 组件间怎么进行通信？"></a>React 组件间怎么进行通信？</h1><p>React 组件间通信可以通过以下方式实现：</p><ol><li>Props 传递：父组件可以通过 Props 将数据传递给子组件，从而实现数据通信。</li><li>Context：Context 是 React 提供的一种组件间通信的机制，可以通过 Context 在组件树中传递数据，避免 Props 层层传递的麻烦。</li><li>Refs：Refs 允许我们直接操作组件实例或者 DOM 元素，从而实现组件间通信。</li><li>自定义事件：可以通过自定义事件的方式实现组件间的通信。在组件中定义一个事件，当需要在其他组件中触发这个事件时，可以通过回调函数的方式实现。</li><li>全局状态管理：使用全局状态管理工具（如 Redux、Mobx）来管理组件状态，从而实现组件间通信。</li></ol><p>需要根据实际场景选择适合的通信方式。</p><h1 id="介绍一下-JS-中-setTimeout-的运行机制？"><a href="#介绍一下-JS-中-setTimeout-的运行机制？" class="headerlink" title="介绍一下 JS 中 setTimeout 的运行机制？"></a>介绍一下 JS 中 setTimeout 的运行机制？</h1><p>在 JavaScript 中，setTimeout() 方法被用于在指定的时间间隔后执行一个指定的代码块。它接受两个参数：第一个参数是需要执行的代码块，第二个参数是代码块的延迟时间（以毫秒为单位）。setTimeout() 方法执行完毕后，代码块将被推入 JavaScript 的执行队列中，等待 JavaScript 引擎在一段时间后执行。</p><p>setTimeout() 方法具有异步的特性，因此即使 setTimeout() 方法指定了一个很短的时间，它也不会在调用代码之后立即执行。相反，它会将代码块放在事件队列的末尾，直到事件队列中没有任何待处理的任务，才会执行。因此，当代码块执行时，当前执行的上下文（也称为堆栈）已经被清空。</p><p>如果 setTimeout() 方法在代码块执行之前被清除或者代码块执行时间过长，那么代码块将会在 JavaScript 引擎空闲时尽快被执行。因此，setTimeout() 方法不是一个精确的时间控制器，而是一个粗略的时间控制器。如果需要更精确的时间控制器，可以考虑使用 requestAnimationFrame() 或 Web Workers。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-如何顺序执行-10-个异步任务？&quot;&gt;&lt;a href=&quot;#JS-如何顺序执行-10-个异步任务？&quot; class=&quot;headerlink&quot; title=&quot;JS 如何顺序执行 10 个异步任务？&quot;&gt;&lt;/a&gt;JS 如何顺序执行 10 个异步任务？&lt;/h1&gt;&lt;p&gt;JS</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day13前端面试题</title>
    <link href="http://example.com/2023/03/05/Day13%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/05/Day13%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-05T11:17:57.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-中，有哪些方式可以隐藏页面元素？有什么区别"><a href="#CSS-中，有哪些方式可以隐藏页面元素？有什么区别" class="headerlink" title="CSS 中，有哪些方式可以隐藏页面元素？有什么区别?"></a>CSS 中，有哪些方式可以隐藏页面元素？有什么区别?</h1><p>在 CSS 中，有以下几种方式可以隐藏页面元素：</p><ol><li>display: none;：完全隐藏元素，元素不占据任何空间。</li><li>visibility: hidden;：隐藏元素，但元素在页面中仍占据空间。</li><li>opacity: 0;：将元素的透明度设为 0，元素隐藏但仍占据空间。</li><li>position: absolute; left: -9999px;：将元素移出屏幕范围之外，元素隐藏但仍占据空间。</li><li>z-index: -1;：将元素的层级设置为负数，元素隐藏但仍占据空间。</li></ol><p>这些方式的区别在于是否占据空间和是否可见，开发者可以根据实际情况选择不同的方式来隐藏页面元素。</p><h1 id="什么是-JS-对象的可枚举性（enumerable）？"><a href="#什么是-JS-对象的可枚举性（enumerable）？" class="headerlink" title="什么是 JS 对象的可枚举性（enumerable）？"></a>什么是 JS 对象的可枚举性（enumerable）？</h1><p>JS 对象的可枚举性指的是对象的某些属性是否可以被 for…in 循环枚举到。每个对象属性都有一个可枚举性标识，这个标识决定了这个属性是否可以被枚举。在对象属性创建时，可以通过 Object.defineProperty() 方法的 enumerable 属性来设置这个属性是否可枚举，默认为 true。</p><p>有些内置对象的属性是不可枚举的，例如 Object.prototype 上的属性，这些属性可以通过 Object.getOwnPropertyNames() 方法获取。</p><p>在 ES6 中，引入了 Object.keys()、Object.values() 和 Object.entries() 方法来获取对象可枚举属性的键、值和键值对。同时，也提供了 Reflect.enumerate() 方法来获取对象的所有属性（包括不可枚举属性），但该方法已经被废弃。</p><h1 id="Vue-中-computed-和-watch-区别？分别适用于什么场景？"><a href="#Vue-中-computed-和-watch-区别？分别适用于什么场景？" class="headerlink" title="Vue 中 computed 和 watch 区别？分别适用于什么场景？"></a>Vue 中 computed 和 watch 区别？分别适用于什么场景？</h1><p>Vue 中的 computed 和 watch 是两种用于响应式数据更新的方法。</p><p>computed 是计算属性，它会根据响应式数据的变化自动计算出新的值，并缓存结果，只有在计算属性所依赖的响应式数据发生改变时才会重新计算。computed 适用于需要根据响应式数据计算得出结果的场景，例如根据商品的数量和单价计算商品的总价，或者根据选中的过滤条件过滤出数据列表。</p><p>watch 是侦听器，它可以监听指定的响应式数据的变化，并在数据发生改变时执行指定的回调函数。watch 适用于需要执行一些异步或复杂操作的场景，例如监听表单输入框的变化并发送 Ajax 请求，或者监听路由变化并根据路由参数切换页面。</p><p>总的来说，computed 适用于计算数据的场景，而 watch 适用于需要执行异步或复杂操作的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-中，有哪些方式可以隐藏页面元素？有什么区别&quot;&gt;&lt;a href=&quot;#CSS-中，有哪些方式可以隐藏页面元素？有什么区别&quot; class=&quot;headerlink&quot; title=&quot;CSS 中，有哪些方式可以隐藏页面元素？有什么区别?&quot;&gt;&lt;/a&gt;CSS 中，有哪些方</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day12前端面试题</title>
    <link href="http://example.com/2023/03/03/Day12%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/03/Day12%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-03T02:25:31.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-脚本延迟加载的方式有哪些？"><a href="#JS-脚本延迟加载的方式有哪些？" class="headerlink" title="JS 脚本延迟加载的方式有哪些？"></a>JS 脚本延迟加载的方式有哪些？</h1><p>JS 脚本的延迟加载主要有以下几种方式：</p><ol><li>defer 属性：在 HTML 中通过设置 script 标签的 defer 属性来实现脚本的延迟加载，即脚本的下载与 HTML 的解析不会阻塞彼此，脚本会在 HTML 解析完成后才执行。</li><li>async 属性：在 HTML 中通过设置 script 标签的 async 属性来实现脚本的异步加载，即脚本的下载与 HTML 的解析不会阻塞彼此，脚本下载完成后会立即执行，但脚本执行时可能会阻塞 HTML 解析。</li><li>动态加载脚本：通过 JavaScript 动态创建 script 标签，并设置其 src 属性来实现脚本的异步加载，这种方式需要在脚本加载完成后手动执行脚本。</li><li>懒加载模式：在需要时再加载脚本，可以使用 jQuery 等库实现，或者通过自己编写的函数来实现。</li></ol><h1 id="什么是点击穿透，怎么解决？"><a href="#什么是点击穿透，怎么解决？" class="headerlink" title="什么是点击穿透，怎么解决？"></a>什么是点击穿透，怎么解决？</h1><p>点击穿透是指在某些场景下，用户在快速点击页面元素时，由于某些原因（例如网络延迟），在前一个元素上的点击事件还没有完成时，下一个元素的点击事件就已经触发了，导致用户感觉到页面点击无效或者出现异常。</p><p>解决点击穿透的方法有以下几种：</p><ol><li>使用 debounce 或 throttle 函数。这两种函数可以控制函数的执行频率，减少短时间内函数的执行次数，从而减少点击穿透的可能性。</li><li>使用 CSS pointer-events 属性。将当前元素的 pointer-events 属性设为 none，可以禁用当前元素的鼠标事件，从而避免在事件处理函数执行过程中发生点击穿透。</li><li>使用 touch 事件代替 click 事件。在移动设备上，click 事件有 300ms 的延迟，可能会导致点击穿透。使用 touchstart、touchend 等 touch 事件可以避免这个问题。</li><li>在 click 事件中使用 preventDefault 函数。在 click 事件的处理函数中调用 preventDefault 函数，可以阻止默认的事件行为，从而避免点击穿透。但是这种方法有可能会影响到一些用户习惯，因此需要慎用。</li></ol><h1 id="你常用的-React-Hooks-有哪些"><a href="#你常用的-React-Hooks-有哪些" class="headerlink" title="你常用的 React Hooks 有哪些?"></a>你常用的 React Hooks 有哪些?</h1><p>React Hooks 是 React 16.8.0 引入的一个新特性，它可以让我们在函数组件中使用 state、生命周期等特性，不再需要使用类组件。我常用的 React Hooks 包括：</p><ol><li>useState：用于在函数组件中使用 state，可以通过调用 useState 方法来设置初始值，返回一个数组，包含当前的 state 值和一个更新 state 值的函数。</li><li>useEffect：用于在函数组件中使用生命周期，可以通过调用 useEffect 方法来实现 componentDidMount、componentDidUpdate 和 componentWillUnmount。</li><li>useContext：用于在函数组件中使用 context，可以通过调用 useContext 方法来获取 context 的值。</li><li>useRef：用于在函数组件中使用 ref，可以通过调用 useRef 方法来创建一个 ref 对象，可以用于获取组件的 DOM 元素或保存一个值，在组件重新渲染时不会改变。</li><li>useMemo：用于在函数组件中使用记忆化计算，可以通过调用 useMemo 方法来缓存计算结果，避免重复计算。</li><li>useCallback：用于在函数组件中使用记忆化函数，可以通过调用 useCallback 方法来缓存函数，避免重复创建函数。</li></ol><p>这些 Hooks 非常方便，能够大大简化我们编写 React 代码的过程，提高开发效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-脚本延迟加载的方式有哪些？&quot;&gt;&lt;a href=&quot;#JS-脚本延迟加载的方式有哪些？&quot; class=&quot;headerlink&quot; title=&quot;JS 脚本延迟加载的方式有哪些？&quot;&gt;&lt;/a&gt;JS 脚本延迟加载的方式有哪些？&lt;/h1&gt;&lt;p&gt;JS 脚本的延迟加载主要有以</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Day11前端面试题</title>
    <link href="http://example.com/2023/03/02/Day11%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/02/Day11%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-02T03:52:04.000Z</published>
    <updated>2023-03-19T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端有哪些实现跨页面通信的方法？"><a href="#前端有哪些实现跨页面通信的方法？" class="headerlink" title="前端有哪些实现跨页面通信的方法？"></a>前端有哪些实现跨页面通信的方法？</h1><p>前端有以下几种实现跨页面通信的方法：</p><ol><li>Cookie：通过在页面间共享 Cookie 实现简单的跨页面通信，但是 Cookie 大小有限制，不能存储过多的数据。</li><li>localStorage 和 sessionStorage：HTML5 提供了本地存储的能力，可以通过 localStorage 或 sessionStorage 实现页面间数据共享，相比 Cookie 更加方便，但是也有大小限制。</li><li>BroadcastChannel API：这是一个 HTML5 新增的 API，允许多个页面间通信，可以广播消息或向特定页面发送消息。</li><li>SharedWorker：SharedWorker 是一种特殊类型的 Web Worker，可以在多个页面间共享数据，可以通过 postMessage API 实现消息传递。</li><li>postMessage API：这是 HTML5 提供的一种消息传递机制，可以在不同窗口或 iframe 间传递消息，可以用来实现跨域通信。</li><li>WebSocket：WebSocket 是一种持久化的协议，可以在浏览器和服务器之间实现双向通信，也可以在不同页面之间实现通信。</li></ol><h1 id="TypeScript-的内置数据类型有哪些？"><a href="#TypeScript-的内置数据类型有哪些？" class="headerlink" title="TypeScript 的内置数据类型有哪些？"></a>TypeScript 的内置数据类型有哪些？</h1><p>TypeScript 的内置数据类型包括：</p><ol><li>boolean：布尔类型，true 或 false。</li><li>number：数值类型，包括整数和浮点数。</li><li>string：字符串类型，表示文本。</li><li>Array：数组类型，可以存储多个相同类型的值。</li><li>Tuple：元组类型，可以存储多个不同类型的值，每个值的类型可以自定义。</li><li>Enum：枚举类型，用于定义一些具有特定含义的常量。</li><li>any：任意类型，表示不确定的数据类型。</li><li>void：空类型，表示没有返回值。</li><li>null 和 undefined：表示 null 和 undefined 值。</li><li>never：表示永远不会返回的类型。</li></ol><h1 id="什么是虚拟-DOM？使用虚拟-DOM-一定更快吗？"><a href="#什么是虚拟-DOM？使用虚拟-DOM-一定更快吗？" class="headerlink" title="什么是虚拟 DOM？使用虚拟 DOM 一定更快吗？"></a>什么是虚拟 DOM？使用虚拟 DOM 一定更快吗？</h1><p>虚拟 DOM（Virtual DOM）是一种将浏览器 DOM 抽象为 JavaScript 对象的技术，用于提高 DOM 操作的效率和性能。虚拟 DOM 可以在渲染前对组件的变化进行计算，减少 DOM 操作的次数，从而提高渲染性能。</p><p>使用虚拟 DOM 可以提高性能，但并不是一定更快。虚拟 DOM 需要进行额外的计算和比较操作，而这些操作也会消耗一定的时间和性能。因此，虚拟 DOM 适用于大规模、高度动态的页面，而在简单的静态页面中使用虚拟 DOM 并不能提高性能。此外，虚拟 DOM 还可以提高开发效率，使代码更易于维护和调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端有哪些实现跨页面通信的方法？&quot;&gt;&lt;a href=&quot;#前端有哪些实现跨页面通信的方法？&quot; class=&quot;headerlink&quot; title=&quot;前端有哪些实现跨页面通信的方法？&quot;&gt;&lt;/a&gt;前端有哪些实现跨页面通信的方法？&lt;/h1&gt;&lt;p&gt;前端有以下几种实现跨页面通信</summary>
      
    
    
    
    
  </entry>
  
</feed>
